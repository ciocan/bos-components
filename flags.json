{
  "components": {
    "ciocan.near/widget/burrow": {
      "code": "const Container = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 2rem;\n\n  .list .btn-outline-primary {\n    --bs-btn-bg: rgba(0, 0, 0, 0.05);\n    --bs-btn-color: rgba(0, 0, 0, 0.4);\n    --bs-btn-border-color: none;\n    --bs-btn-active-color: #000;\n    --bs-btn-active-bg: #fff;\n    --bs-btn-bg: #fff;\n  }\n\n  .action .btn-outline-primary {\n    --bs-btn-bg: rgba(0, 0, 0, 0.05);\n    --bs-btn-color: rgba(0, 0, 0, 0.4);\n    --bs-btn-border-color: rgba(0, 0, 0, 0.1);\n    --bs-btn-hover-color: #fff;\n    --bs-btn-hover-bg: rgba(0, 0, 0, 0.1);\n    --bs-btn-hover-border-color: #0d6efd;\n    --bs-btn-focus-shadow-rgb: 13,110,253;\n    --bs-btn-active-color: #000;\n    --bs-btn-active-bg: #fff;\n    --bs-btn-active-border-color: rgba(0, 0, 0, 0.1);\n  }\n\n  .badge {\n    color: #4ED58A !important;\n    background: rgba(71, 200, 128, 0.1) !important;\n  }\n`;\n\nconst Nav = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 2rem;\n`;\n\nconst Main = styled.div`\n  display: flex;\n  flex-direction: row;\n  gap: 1rem;\n`;\n\nconst LeftPanel = styled.div`\n  width: 60%;\n  border-right: 1px solid rgba(0, 0, 0, 0.1);\n  min-height: 400px;\n  padding-right: 2rem;\n`;\n\nconst RightPanel = styled.div`\n  padding-left: 1rem;\n`;\n\nif (!state.actionTabs) {\n  State.update({ actionTabs: \"deposit\" });\n}\n\nif (!state.actionList) {\n  State.update({ actionList: \"assets\" });\n}\n\nconst tabContents = () => {\n  switch (state.actionTabs) {\n    case \"borrow\":\n      return <Widget src=\"ciocan.near/widget/burrow-borrow\" />;\n    case \"deposit\":\n      return <Widget src=\"ciocan.near/widget/burrow-deposit\" />;\n    case \"repay\":\n      return <Widget src=\"ciocan.near/widget/burrow-repay\" />;\n  }\n};\n\nreturn (\n  <Container>\n    <Nav>\n      <div class=\"fw-bold\">Burrow</div>\n      <div class=\"list btn-group\" role=\"group\" aria-label=\"List\">\n        <input\n          type=\"radio\"\n          class=\"btn-check\"\n          name=\"btnradiolist\"\n          id=\"assets\"\n          autocomplete=\"off\"\n          checked={state.actionList === \"assets\"}\n          onClick={() => State.update({ actionList: \"assets\" })}\n        />\n        <label class=\"btn btn-outline-primary\" for=\"assets\">\n          Assets\n        </label>\n        <input\n          type=\"radio\"\n          class=\"btn-check\"\n          name=\"btnradiolist\"\n          id=\"portfolio\"\n          autocomplete=\"off\"\n          checked={state.actionList === \"portfolio\"}\n          onClick={() => State.update({ actionList: \"portfolio\" })}\n        />\n        <label class=\"btn btn-outline-primary\" for=\"portfolio\">\n          Portfolio\n        </label>\n      </div>\n    </Nav>\n    <Main>\n      <LeftPanel>\n        {state.actionList === \"assets\" ? (\n          <Widget src=\"ciocan.near/widget/burrow-list\" />\n        ) : (\n          <Widget src=\"ciocan.near/widget/burrow-portfolio\" />\n        )}\n      </LeftPanel>\n      <RightPanel>\n        <div class=\"action btn-group mb-4\" role=\"group\" aria-label=\"Deposit\">\n          <input\n            type=\"radio\"\n            class=\"btn-check\"\n            name=\"btnradioaction\"\n            id=\"deposit\"\n            autocomplete=\"off\"\n            checked={state.actionTabs === \"deposit\"}\n            onClick={() => State.update({ actionTabs: \"deposit\" })}\n          />\n          <label class=\"btn btn-outline-primary\" for=\"deposit\">\n            Deposit\n          </label>\n          <input\n            type=\"radio\"\n            class=\"btn-check\"\n            name=\"btnradioaction\"\n            id=\"borrow\"\n            autocomplete=\"off\"\n            checked={state.actionTabs === \"borrow\"}\n            onClick={() => State.update({ actionTabs: \"borrow\" })}\n          />\n          <label class=\"btn btn-outline-primary\" for=\"borrow\">\n            Borrow\n          </label>\n          <input\n            type=\"radio\"\n            class=\"btn-check\"\n            name=\"btnradioaction\"\n            id=\"repay\"\n            autocomplete=\"off\"\n            checked={state.actionTabs === \"repay\"}\n            onClick={() => State.update({ actionTabs: \"repay\" })}\n          />\n          <label class=\"btn btn-outline-primary\" for=\"repay\">\n            Repay\n          </label>\n        </div>\n        {tabContents()}\n        <div class=\"mt-4\">\n          <Widget src=\"ciocan.near/widget/burrow-rewards\" />\n        </div>\n      </RightPanel>\n    </Main>\n  </Container>\n);\n"
    },
    "ciocan.near/widget/burrow-deposit": {
      "code": "let BURROW_CONTRACT = \"contract.main.burrow.near\";\nlet accountId = context.accountId;\n\nif (!accountId) {\n  return <Widget src=\"ciocan.near/widget/account-signin\" />;\n}\n\nconst { selectedTokenId, amount, hasError, assets, rewards } = state;\n\nconst hasData = assets.length > 0 && rewards.length > 0;\n\nconst onLoad = (data) => {\n  State.update(data);\n};\n\nconst shrinkToken = (value, decimals) => {\n  return new Big(value).div(new Big(10).pow(decimals));\n};\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nconst formatToken = (v) => Math.floor(v * 10_000) / 10_000;\n\nconst account = fetch(\"https://rpc.mainnet.near.org\", {\n  method: \"POST\",\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({\n    jsonrpc: \"2.0\",\n    id: \"dontcare\",\n    method: \"query\",\n    params: {\n      request_type: \"view_account\",\n      finality: \"final\",\n      account_id: accountId,\n    },\n  }),\n});\n\nif (!account) return <div>loading...</div>;\n\nconst nearBalance = shrinkToken(account.body.result.amount, 24).toFixed(2);\n\nconst toAPY = (v) => Math.round(v * 100) / 100;\n\nconst listAssets =\n  assets &&\n  assets\n    ?.filter((a) => a.accountBalance > 0)\n    ?.map((asset) => {\n      const { token_id, accountBalance, metadata } = asset;\n      const balance = formatToken(\n        shrinkToken(accountBalance, metadata.decimals).toFixed()\n      ).toString();\n\n      const r = rewards.find((a) => a.token_id === asset.token_id);\n      const totalApy = r.apyBase + r.apyRewardTvl + r.apyReward;\n\n      const spaces = \"\".padStart(15 - (metadata.symbol + balance).length, \"-\");\n\n      return <option value={token_id}>{metadata.symbol}</option>;\n    });\n\nlet vailableBalance = 0;\nlet apy = 0;\n\nconst getBalance = (asset) => {\n  if (!asset) return 0;\n  const { token_id, accountBalance, metadata } = asset;\n  return formatToken(\n    shrinkToken(accountBalance, metadata.decimals).toFixed()\n  ).toString();\n};\n\nconst getApy = (asset) => {\n  if (!asset) return 0;\n  const r = rewards.find((a) => a.token_id === asset.token_id);\n  const totalApy = r.apyBase + r.apyRewardTvl + r.apyReward;\n  return toAPY(totalApy);\n};\n\nif (selectedTokenId) {\n  const token = selectedTokenId === \"NEAR\" ? \"wrap.near\" : selectedTokenId;\n  const asset = assets.find((a) => a.token_id === token);\n  vailableBalance =\n    selectedTokenId === \"NEAR\" ? nearBalance : getBalance(asset);\n  apy = getApy(asset);\n}\n\nconst storageBurrow = Near.view(BURROW_CONTRACT, \"storage_balance_of\", {\n  account_id: accountId,\n});\n\nconst storageToken = selectedTokenId\n  ? Near.view(selectedTokenId, \"storage_balance_of\", {\n      account_id: accountId,\n    })\n  : null;\n\nconst handleSelect = (e) => {\n  State.update({\n    selectedTokenId: e.target.value,\n    amount: \"\",\n    hasError: false,\n  });\n};\n\nconst handleAmount = (e) => {\n  State.update({\n    amount: Number(e.target.value),\n    selectedTokenId,\n    hasError: false,\n  });\n};\n\nconst handleDeposit = () => {\n  if (!selectedTokenId || !amount || hasError) return;\n\n  if (selectedTokenId === \"NEAR\") {\n    handleDepositNear(amount);\n    return;\n  }\n\n  const asset = assets.find((a) => a.token_id === selectedTokenId);\n  const { token_id, accountBalance, metadata, config } = asset;\n\n  const balance = formatToken(\n    shrinkToken(accountBalance, metadata.decimals).toFixed()\n  );\n\n  if (amount > balance) {\n    State.update({ selectedTokenId, amount, hasError: true });\n    return;\n  }\n\n  const expandedAmount = expandToken(amount, metadata.decimals).toFixed();\n  const collateralAmount = expandToken(\n    amount,\n    metadata.decimals + config.extra_decimals\n  ).toFixed();\n\n  const collateralMsg = config.can_use_as_collateral\n    ? `{\"Execute\":{\"actions\":[{\"IncreaseCollateral\":{\"token_id\": \"${token_id}\",\"max_amount\":\"${collateralAmount}\"}}]}}`\n    : \"\";\n\n  const transactions = [];\n\n  const depositTransaction = {\n    contractName: token_id,\n    methodName: \"ft_transfer_call\",\n    deposit: new Big(\"1\").toFixed(),\n    gas: expandToken(300, 12),\n    args: {\n      receiver_id: BURROW_CONTRACT,\n      amount: expandedAmount,\n      msg: collateralMsg,\n    },\n  };\n\n  if (storageToken?.available === \"0\" || !storageToken?.available) {\n    transactions.push({\n      contractName: token_id,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.25, 24).toFixed(),\n    });\n  }\n\n  if (storageBurrow?.available === \"0\" || !storageBurrow?.available) {\n    transactions.push({\n      contractName: BURROW_CONTRACT,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.25, 24).toFixed(),\n      gas: expandToken(140, 12),\n    });\n  }\n\n  transactions.push(depositTransaction);\n\n  Near.call(transactions);\n};\n\nconst handleDepositNear = (amount) => {\n  const amountDecimal = expandToken(amount, 24).toFixed();\n\n  Near.call([\n    {\n      contractName: \"wrap.near\",\n      methodName: \"near_deposit\",\n      deposit: amountDecimal,\n      gas: expandToken(300, 12),\n    },\n    {\n      contractName: \"wrap.near\",\n      methodName: \"ft_transfer_call\",\n      deposit: new Big(\"1\").toFixed(),\n      gas: expandToken(300, 12),\n      args: {\n        receiver_id: BURROW_CONTRACT,\n        amount: amountDecimal,\n        msg: `{\"Execute\":{\"actions\":[{\"IncreaseCollateral\":{\"token_id\":\"wrap.near\",\"max_amount\":\"${amountDecimal}\"}}]}}`,\n      },\n    },\n  ]);\n};\n\nreturn (\n  <div style={{ maxWidth: \"300px\" }}>\n    {!hasData && (\n      <Widget src=\"ciocan.near/widget/burrow-data\" props={{ onLoad }} />\n    )}\n    <div class=\"card-body d-grid gap-3\">\n      <div>\n        <div class=\"mb-2 text-muted\">From</div>\n        <select\n          onChange={handleSelect}\n          class=\"p-2 mb-1\"\n          style={{ width: \"100%\" }}\n        >\n          <option value=\"\">Deposit an asset</option>\n          <option value=\"NEAR\">NEAR Wallet</option>\n          {listAssets}\n        </select>\n        <div>\n          <span class=\"badge bg-light text-dark\">\n            {vailableBalance} available\n          </span>\n          <span class=\"badge bg-light text-dark\">{apy}% APY</span>\n        </div>\n      </div>\n      <div>\n        <div class=\"mb-2 text-muted\">Amount</div>\n        <input type=\"number\" value={amount} onChange={handleAmount} />\n      </div>\n      {hasError && (\n        <p class=\"alert alert-danger\" role=\"alert\">\n          Amount greater than balance\n        </p>\n      )}\n      <button\n        onClick={handleDeposit}\n        style={{ background: \"#4ED58A\", borderColor: \"white\" }}\n      >\n        Deposit\n      </button>\n    </div>\n  </div>\n);\n"
    },
    "ciocan.near/widget/burrow-borrow": {
      "code": "let MAX_RATIO = 10_000;\nlet BURROW_CONTRACT = \"contract.main.burrow.near\";\nlet accountId = context.accountId;\n\nlet B = Big();\nB.DP = 60; // set precision to 60 decimals\n\nconst toAPY = (v) => Math.round(v * 100) / 100;\nconst clone = (o) => JSON.parse(JSON.stringify(o));\n\nconst { selectedTokenId, amount, hasError, assets, rewards } = state;\n\nconst hasData = assets.length > 0 && rewards.length > 0;\n\nconst onLoad = (data) => {\n  State.update(data);\n};\n\nconst shrinkToken = (value, decimals) => {\n  return B(value).div(B(10).pow(decimals));\n};\n\nconst expandToken = (value, decimals) => {\n  return B(value).mul(B(10).pow(decimals));\n};\n\nconst formatToken = (v) => Math.floor(v * 10_000) / 10_000;\n\nif (!accountId) {\n  return <Widget src=\"ciocan.near/widget/account-signin\" />;\n}\n\nconst config = Near.view(BURROW_CONTRACT, \"get_config\");\n\nconst account = Near.view(BURROW_CONTRACT, \"get_account\", {\n  account_id: accountId,\n});\n\nif (!account) return <div>loading...</div>;\n\n// sum all assets to get the health factor\n// https://github.com/burrowfdn/burrowland for detailed explanation\nfunction getAdjustedSum(type, account) {\n  if (!assets || !account) return B(1);\n\n  const sumArr = account[type].map((assetInAccount) => {\n    const asset = assets.find((a) => a.token_id === assetInAccount.token_id);\n    const hasPrice = !!asset.price?.multiplier && !!asset.price?.decimals;\n\n    const price = hasPrice\n      ? B(asset.price.multiplier).div(B(10).pow(asset.price.decimals))\n      : B(0);\n\n    const pricedBalance = B(assetInAccount.balance)\n      .div(expandToken(1, asset.config.extra_decimals))\n      .mul(price);\n\n    return type === \"borrowed\"\n      ? pricedBalance\n          .div(asset.config.volatility_ratio)\n          .mul(MAX_RATIO)\n          .toFixed()\n      : pricedBalance\n          .mul(asset.config.volatility_ratio)\n          .div(MAX_RATIO)\n          .toFixed();\n  });\n  // .reduce((acc, cur) => B(acc).plus(B(cur)), 1);\n  // .toFixed();\n  let sum = B(0.001);\n  sumArr.forEach((e) => (sum = sum.plus(B(e))));\n  return sum;\n}\n\nconst adjustedCollateralSum = getAdjustedSum(\"collateral\", account);\nconst adjustedBorrowedSum = getAdjustedSum(\"borrowed\", account);\n\nfunction getHealthFactor() {\n  const healthFactor = B(adjustedCollateralSum)\n    .div(B(adjustedBorrowedSum))\n    .mul(100)\n    .toFixed(0);\n  return Number(healthFactor) < MAX_RATIO ? healthFactor : MAX_RATIO;\n}\n\nconst healthFactor = getHealthFactor();\n\nconst recomputeHealthFactor = (tokenId, amount) => {\n  if (!tokenId || !amount) return null;\n  const asset = assets.find((a) => a.token_id === tokenId);\n  const decimals = asset.metadata.decimals + asset.config.extra_decimals;\n  const accountBorrowedAsset = account.borrowed.find(\n    (a) => a.token_id === tokenId\n  );\n\n  const newBalance = expandToken(amount, decimals)\n    .plus(B(accountBorrowedAsset?.balance || 0))\n    .toFixed();\n\n  const clonedAccount = clone(account);\n\n  const updatedToken = {\n    token_id: tokenId,\n    balance: newBalance,\n    shares: newBalance,\n    apr: \"0\",\n  };\n\n  if (clonedAccount?.borrowed.length === 0) {\n    clonedAccount.borrowed = updatedToken;\n  } else if (!accountBorrowedAsset) {\n    clonedAccount.borrowed.push(updatedToken);\n  } else {\n    clonedAccount.borrowed = [\n      ...clonedAccount.borrowed.filter((a) => a.token_id !== tokenId),\n      updatedToken,\n    ];\n  }\n\n  const adjustedCollateralSum = getAdjustedSum(\"collateral\", account);\n  const adjustedBorrowedSum = getAdjustedSum(\n    \"borrowed\",\n    amount === 0 ? account : clonedAccount\n  );\n\n  const newHealthFactor = B(adjustedCollateralSum)\n    .div(B(adjustedBorrowedSum))\n    .mul(100)\n    .toNumber();\n\n  return newHealthFactor;\n};\n\n// get max ammount can be borrowed\nfunction getMaxAmount() {\n  if (!selectedTokenId) return 0;\n  const asset = assets.find((a) => a.token_id === selectedTokenId);\n  const volatiliyRatio = asset.config.volatility_ratio || 0;\n  const price = asset.price?.usd || Infinity;\n\n  const available = Number(\n    B(adjustedCollateralSum)\n      .sub(B(adjustedBorrowedSum))\n      .mul(volatiliyRatio)\n      .div(MAX_RATIO)\n      .div(price)\n      .mul(95)\n      .div(100)\n      .toFixed(4)\n  );\n  return [available, (asset.price.usd * available).toFixed(2)];\n}\nconst [available, availableUSD] = getMaxAmount();\n\nconst listAssets =\n  assets &&\n  assets\n    ?.filter((a) => a.config.can_borrow)\n    ?.map((asset) => {\n      const { token_id, metadata } = asset;\n      return <option value={token_id}>{metadata.symbol}</option>;\n    });\n\nconst storageBurrow = Near.view(BURROW_CONTRACT, \"storage_balance_of\", {\n  account_id: accountId,\n});\n\n// get the storage deposit for a token\nconst storageToken = selectedTokenId\n  ? Near.view(selectedTokenId, \"storage_balance_of\", {\n      account_id: accountId,\n    })\n  : null;\n\nconst handleSelect = (e) => {\n  State.update({\n    selectedTokenId: e.target.value,\n    amount: \"\",\n    hasError: false,\n  });\n};\n\nconst handleAmount = (e) => {\n  State.update({\n    amount: Number(e.target.value),\n    selectedTokenId,\n    hasError: false,\n  });\n};\n\nconst handleBlur = (e) => {\n  State.update({\n    newHealthFactor: recomputeHealthFactor(selectedTokenId, amount),\n  });\n};\n\nconst handleBorrow = () => {\n  if (!selectedTokenId || !amount || hasError) return;\n  const asset = assets.find((a) => a.token_id === selectedTokenId);\n\n  if (amount > available) {\n    State.update({ selectedTokenId, amount, hasError: true });\n    return;\n  }\n\n  const transactions = [];\n\n  const expandedAmount = expandToken(\n    amount,\n    asset.metadata.decimals + asset.config.extra_decimals\n  );\n\n  const borrowTemplate = {\n    Execute: {\n      actions: [\n        {\n          Borrow: {\n            token_id: selectedTokenId,\n            amount: expandedAmount.toFixed(0),\n          },\n        },\n        {\n          Withdraw: {\n            token_id: selectedTokenId,\n            max_amount: expandedAmount.toFixed(0),\n          },\n        },\n      ],\n    },\n  };\n\n  const borrowTransaction = {\n    contractName: config.oracle_account_id,\n    methodName: \"oracle_call\",\n    deposit: B(\"1\").toFixed(),\n    gas: expandToken(300, 12),\n    args: {\n      receiver_id: BURROW_CONTRACT,\n      msg: JSON.stringify(borrowTemplate),\n    },\n  };\n\n  if (storageToken?.available === \"0\" || !storageToken?.available) {\n    transactions.push({\n      contractName: selectedTokenId,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.25, 24).toFixed(),\n    });\n  }\n\n  if (storageBurrow?.available === \"0\" || !storageBurrow?.available) {\n    transactions.push({\n      contractName: BURROW_CONTRACT,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.25, 24).toFixed(),\n      gas: expandToken(140, 12),\n    });\n  }\n\n  transactions.push(borrowTransaction);\n\n  if (\n    [\"wrap.near\", \"wrap.testnet\"].includes(selectedTokenId) &&\n    expandedAmount.gt(10)\n  ) {\n    transactions.push({\n      contractName: selectedTokenId,\n      methodName: \"near_withdraw\",\n      deposit: B(\"1\").toFixed(),\n      args: {\n        amount: expandedAmount.sub(10).toFixed(0),\n      },\n    });\n  }\n\n  Near.call(transactions);\n};\n\nconst reward = rewards && rewards.find((a) => a.token_id === selectedTokenId);\n\nconst newHealthFactor = state.newHealthFactor\n  ? state.newHealthFactor?.toFixed()\n  : undefined;\n\nreturn (\n  <div style={{ maxWidth: \"300px\" }}>\n    {!hasData && (\n      <Widget src=\"ciocan.near/widget/burrow-data\" props={{ onLoad }} />\n    )}\n    <div class=\"card-body d-grid gap-3\">\n      <div>\n        <div class=\"mb-2 text-muted\">From</div>\n        <select\n          onChange={handleSelect}\n          class=\"p-2 mb-1\"\n          style={{ width: \"100%\" }}\n        >\n          <option value=\"\">Borrow an asset</option>\n          {listAssets}\n        </select>\n        {selectedTokenId && (\n          <div>\n            <span class=\"badge bg-light text-dark\">\n              {available} (${availableUSD}) available\n            </span>\n            <span class=\"badge bg-light text-dark\">\n              {toAPY(reward.apyBaseBorrow)}% APY\n            </span>\n          </div>\n        )}\n      </div>\n      <div>\n        <div class=\"mb-2 text-muted\">Amount</div>\n        <input\n          type=\"number\"\n          value={amount}\n          onChange={handleAmount}\n          onBlur={handleBlur}\n        />\n        {hasError && (\n          <p class=\"alert alert-danger\" role=\"alert\">\n            Amount greater than available\n          </p>\n        )}\n      </div>\n      <div>\n        <span class=\"badge bg-light text-dark\">\n          {healthFactor}% health{\" \"}\n          {newHealthFactor && <span>(after borrow: {newHealthFactor}%)</span>}\n        </span>\n      </div>\n      <button\n        onClick={handleBorrow}\n        style={{ background: \"#4ED58A\", borderColor: \"white\" }}\n      >\n        Borrow\n      </button>\n    </div>\n  </div>\n);\n"
    },
    "ciocan.near/widget/Burrow.Data": {
      "code": "const accountId = context.accountId;\n\nconst unique = (value, index, self) => {\n  return self.indexOf(value) === index;\n};\n\nconst sumReducer = (sum, a) => sum + a;\n\nfunction power(x, y) {\n  if (y === 0) {\n    return 1;\n  } else if (y % 2 === 0) {\n    return power(x, parseInt(y / 2)) * power(x, parseInt(y / 2));\n  } else {\n    return x * power(x, parseInt(y / 2)) * power(x, parseInt(y / 2));\n  }\n}\n\nconst toUsd = (balance, asset) =>\n  asset?.price?.usd\n    ? Number(\n        shrinkToken(\n          balance,\n          asset.metadata.decimals + asset.config.extra_decimals\n        )\n      ) * asset.price.usd\n    : 0;\n\nconst shrinkToken = (value, decimals, fixed) => {\n  return new Big(value).div(new Big(10).pow(decimals)).toFixed(fixed);\n};\n\nfunction getAssets() {\n  const assets = Near.view(\"contract.main.burrow.near\", \"get_assets_paged\");\n  if (!assets) return;\n  const tokenIds = assets?.map(([id]) => id);\n  const assetsDetailed = tokenIds.map((token_id) =>\n    Near.view(\"contract.main.burrow.near\", \"get_asset\", { token_id })\n  );\n  if (!assetsDetailed) return;\n  const metadata = tokenIds?.map((token_id) =>\n    Near.view(token_id, \"ft_metadata\")\n  );\n  if (!metadata) return;\n\n  const config = Near.view(\"contract.main.burrow.near\", \"get_config\");\n  if (!config) return;\n\n  const prices =\n    config && Near.view(config?.[\"oracle_account_id\"], \"get_price_data\");\n\n  if (!prices) return;\n\n  const refPricesResponse = fetch(\n    \"https://raw.githubusercontent.com/NearDeFi/token-prices/main/ref-prices.json\"\n  );\n  const refPrices = JSON.parse(refPricesResponse.body);\n\n  if (!config || !prices || !refPricesResponse) return;\n\n  const balances = accountId\n    ? tokenIds.map((token_id) =>\n        Near.view(token_id, \"ft_balance_of\", { account_id: accountId })\n      )\n    : undefined;\n\n  return assetsDetailed?.map((asset, i) => {\n    const price = prices?.prices?.find((p) => p.asset_id === asset?.token_id);\n    const decimals =\n      parseInt(price?.price?.decimals || 0) - parseInt(metadata?.[i].decimals);\n    const usd = price?.price?.multiplier / power(10, decimals);\n\n    return {\n      ...asset,\n      metadata: metadata?.[i],\n      accountBalance: accountId ? balances?.[i] : undefined,\n      price: {\n        ...price.price,\n        usd: usd ? usd : parseFloat(refPrices?.[asset.token_id]?.price),\n      },\n    };\n  });\n}\n\nconst getTotalBalance = (assets, source) =>\n  assets\n    .map((asset) => {\n      const netTvlMultiplier = asset.config.net_tvl_multiplier / 10000;\n      return (\n        toUsd(asset[source].balance, asset) * netTvlMultiplier +\n        (source === \"supplied\"\n          ? toUsd(asset.reserved, asset) * netTvlMultiplier\n          : 0)\n      );\n    })\n    .reduce(sumReducer, 0);\n\nconst getNetLiquidityAPY = (assets, netLiquidityFarm) => {\n  const totalDailyNetLiquidityRewards = Object.entries(netLiquidityFarm.rewards)\n    .map(([rewardTokenId, farm]) => {\n      const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n      const assetDecimals =\n        rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n      const dailyAmount = Number(\n        shrinkToken(farm.reward_per_day, assetDecimals)\n      );\n      return (\n        dailyAmount *\n        rewardAsset.price.usd *\n        (rewardAsset.config.net_tvl_multiplier / 10000)\n      );\n    })\n    .reduce(sumReducer, 0);\n\n  const supplied = getTotalBalance(assets, \"supplied\");\n  const borrowed = getTotalBalance(assets, \"borrowed\");\n\n  const totalProtocolLiquidity = supplied - borrowed;\n  const netLiquidtyAPY =\n    ((totalDailyNetLiquidityRewards * 365) / totalProtocolLiquidity) * 100;\n\n  const rewardTokens = Object.entries(netLiquidityFarm.rewards).map(\n    ([rewardTokenId]) => rewardTokenId\n  );\n\n  return [netLiquidtyAPY, rewardTokens];\n};\n\nconst getRewards = (assets) => {\n  const netLiquidityFarm = Near.view(\n    \"contract.main.burrow.near\",\n    \"get_asset_farm\",\n    { farm_id: \"NetTvl\" }\n  );\n\n  if (!netLiquidityFarm) return;\n\n  const [apyRewardTvl, rewardTokensTVL] = getNetLiquidityAPY(\n    assets,\n    netLiquidityFarm\n  );\n\n  const rewards = assets.map((asset) => {\n    const apyBase = asset[\"supply_apr\"] * 100;\n    const apyBaseBorrow = asset[\"borrow_apr\"] * 100;\n    const tokenId = asset.token_id;\n    const totalSupplyUsd = toUsd(asset.supplied.balance, asset);\n    const totalBorrowUsd = toUsd(asset.borrowed.balance, asset);\n\n    const suppliedFarmRewards =\n      asset.farms.find((farm) => farm.farm_id.Supplied === tokenId)?.rewards ||\n      {};\n\n    const rewardTokens = Object.entries(suppliedFarmRewards)\n      .map(([rewardTokenId]) => rewardTokenId)\n      .concat(rewardTokensTVL)\n      .filter(unique);\n\n    const apyRewards = Object.entries(suppliedFarmRewards).map(\n      ([rewardTokenId, reward]) => {\n        const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n        const decimals =\n          rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n        const price = rewardAsset.price?.usd || 0;\n        return (\n          new Big(reward.reward_per_day)\n            .div(new Big(10).pow(decimals))\n            .mul(365)\n            .mul(price)\n            .div(totalSupplyUsd)\n            .mul(100)\n            .toNumber() || 0\n        );\n      }\n    );\n\n    const apyReward = apyRewards.reduce(sumReducer, 0);\n\n    const borrowedFarmRewards =\n      asset.farms.find((farm) => farm.farm_id.Borrowed === tokenId)?.rewards ||\n      {};\n\n    const rewardTokensBorrow = Object.entries(borrowedFarmRewards).map(\n      ([rewardTokenId]) => rewardTokenId\n    );\n\n    const apyRewardBorrow = Object.entries(borrowedFarmRewards)\n      .map(([rewardTokenId, reward]) => {\n        const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n        const decimals =\n          rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n        const price = rewardAsset.price?.usd || 0;\n\n        if (!totalBorrowUsd) return 0;\n\n        return (\n          new Big(reward.reward_per_day)\n            .div(new Big(10).pow(decimals))\n            .mul(365)\n            .mul(price)\n            .div(totalBorrowUsd)\n            .mul(100)\n            .toNumber() || 0\n        );\n      })\n      .reduce(sumReducer, 0);\n\n    return {\n      token_id: asset.token_id,\n      symbol: asset.metadata.symbol,\n      tvlUsd: totalSupplyUsd - totalBorrowUsd,\n      apyReward,\n      apyRewardTvl: apyRewardTvl || 0,\n      apyBase,\n      rewardTokens,\n      totalSupplyUsd,\n      totalBorrowUsd,\n      apyBaseBorrow,\n      apyRewardBorrow,\n      rewardTokensBorrow,\n      ltv: asset.config.volatility_ratio,\n    };\n  });\n\n  return rewards;\n};\n\nconst assets = getAssets();\n\nif (!assets) return <div />;\n\nconst rewards = getRewards(assets);\n\nif (!rewards) return <div />;\n\nconst data = {\n  assets,\n  rewards,\n};\n\nif (typeof props.onLoad === \"function\") {\n  props.onLoad(data);\n}\n\nreturn <div />;\n"
    },
    "ciocan.near/widget/burrow-data": {
      "code": "const accountId = context.accountId;\nconst BURROW_CONTRACT = \"contract.main.burrow.near\";\n\nconst unique = (value, index, self) => {\n  return self.indexOf(value) === index;\n};\n\nconst sumReducer = (sum, a) => sum + a;\n\nfunction power(x, y) {\n  if (y === 0) {\n    return 1;\n  } else if (y % 2 === 0) {\n    return power(x, parseInt(y / 2)) * power(x, parseInt(y / 2));\n  } else {\n    return x * power(x, parseInt(y / 2)) * power(x, parseInt(y / 2));\n  }\n}\n\nconst toUsd = (balance, asset) =>\n  asset?.price?.usd\n    ? Number(\n        shrinkToken(\n          balance,\n          asset.metadata.decimals + asset.config.extra_decimals\n        )\n      ) * asset.price.usd\n    : 0;\n\n// transform tolen balance from big number decimal to number\nconst shrinkToken = (value, decimals, fixed) => {\n  return new Big(value).div(new Big(10).pow(decimals)).toFixed(fixed);\n};\n\n// get all assets, metadata and pricing from burrow contracts\nfunction getAssets() {\n  const assets = Near.view(BURROW_CONTRACT, \"get_assets_paged\");\n  if (!assets) return;\n  const tokenIds = assets?.map(([id]) => id);\n  const assetsDetailed = tokenIds.map((token_id) =>\n    Near.view(BURROW_CONTRACT, \"get_asset\", { token_id })\n  );\n  if (!assetsDetailed) return;\n  const metadata = tokenIds?.map((token_id) =>\n    Near.view(token_id, \"ft_metadata\")\n  );\n  if (!metadata) return;\n\n  const config = Near.view(BURROW_CONTRACT, \"get_config\");\n  if (!config) return;\n\n  const prices =\n    config && Near.view(config?.[\"oracle_account_id\"], \"get_price_data\");\n\n  const refPricesResponse = fetch(\n    \"https://raw.githubusercontent.com/NearDeFi/token-prices/main/ref-prices.json\"\n  );\n  const refPrices = JSON.parse(refPricesResponse.body);\n\n  if (!config || !prices || !refPricesResponse) return;\n\n  const balances = accountId\n    ? tokenIds.map((token_id) =>\n        Near.view(token_id, \"ft_balance_of\", { account_id: accountId })\n      )\n    : undefined;\n\n  return assetsDetailed?.map((asset, i) => {\n    const price = prices?.prices?.find((p) => p.asset_id === asset?.token_id);\n    const priceDecimals =\n      parseInt(price?.price?.decimals || 0) - parseInt(metadata?.[i].decimals);\n    const usd = price?.price?.multiplier / power(10, priceDecimals);\n\n    const temp = Big(asset.supplied.balance)\n      .plus(Big(asset.reserved))\n      .minus(Big(asset.borrowed.balance));\n\n    const decimals = metadata?.[i].decimals + asset.config.extra_decimals;\n    const availableLiquidity = Number(shrinkToken(temp.toFixed(), decimals));\n\n    return {\n      ...asset,\n      metadata: metadata?.[i],\n      accountBalance: accountId ? balances?.[i] : undefined,\n      price: {\n        ...price.price,\n        usd: usd ? usd : parseFloat(refPrices?.[asset.token_id]?.price),\n      },\n      availableLiquidity,\n    };\n  });\n}\n\n// get balance of every asset on account\nconst getBalances = (assets) => {\n  if (!assets) return;\n  const balances = accountId\n    ? assets.map(({ token_id }) =>\n        Near.view(token_id, \"ft_balance_of\", { account_id: accountId })\n      )\n    : undefined;\n\n  return balances;\n};\n\n// sum all balances for supplied or borrowed\n// it's used for computing the net liquidity apy\nconst getTotalBalance = (assets, source) =>\n  assets\n    .map((asset) => {\n      const netTvlMultiplier = asset.config.net_tvl_multiplier / 10000;\n      return (\n        toUsd(asset[source].balance, asset) * netTvlMultiplier +\n        (source === \"supplied\"\n          ? toUsd(asset.reserved, asset) * netTvlMultiplier\n          : 0)\n      );\n    })\n    .reduce(sumReducer, 0);\n\nconst getNetLiquidityAPY = (assets, netLiquidityFarm) => {\n  const totalDailyNetLiquidityRewards = Object.entries(netLiquidityFarm.rewards)\n    .map(([rewardTokenId, farm]) => {\n      const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n      const assetDecimals =\n        rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n      const dailyAmount = Number(\n        shrinkToken(farm.reward_per_day, assetDecimals)\n      );\n      return (\n        dailyAmount *\n        rewardAsset.price.usd *\n        (rewardAsset.config.net_tvl_multiplier / 10000)\n      );\n    })\n    .reduce(sumReducer, 0);\n\n  const supplied = getTotalBalance(assets, \"supplied\");\n  const borrowed = getTotalBalance(assets, \"borrowed\");\n\n  const totalProtocolLiquidity = supplied - borrowed;\n  const netLiquidtyAPY =\n    ((totalDailyNetLiquidityRewards * 365) / totalProtocolLiquidity) * 100;\n\n  const rewardTokens = Object.entries(netLiquidityFarm.rewards).map(\n    ([rewardTokenId]) => rewardTokenId\n  );\n\n  return [netLiquidtyAPY, rewardTokens];\n};\n\n// get all farm rewards for each asset\nconst getRewards = (assets) => {\n  const netLiquidityFarm = Near.view(BURROW_CONTRACT, \"get_asset_farm\", {\n    farm_id: \"NetTvl\",\n  });\n\n  if (!netLiquidityFarm) return;\n\n  const [apyRewardTvl, rewardTokensTVL] = getNetLiquidityAPY(\n    assets,\n    netLiquidityFarm\n  );\n\n  const rewards = assets.map((asset) => {\n    const apyBase = asset[\"supply_apr\"] * 100;\n    const apyBaseBorrow = asset[\"borrow_apr\"] * 100;\n    const tokenId = asset.token_id;\n    const totalSupplyUsd = toUsd(asset.supplied.balance, asset);\n    const totalBorrowUsd = toUsd(asset.borrowed.balance, asset);\n\n    const suppliedFarmRewards =\n      asset.farms.find((farm) => farm.farm_id.Supplied === tokenId)?.rewards ||\n      {};\n\n    const rewardTokens = Object.entries(suppliedFarmRewards)\n      .map(([rewardTokenId]) => rewardTokenId)\n      .concat(rewardTokensTVL)\n      .filter(unique);\n\n    const apyRewards = Object.entries(suppliedFarmRewards).map(\n      ([rewardTokenId, reward]) => {\n        const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n        const decimals =\n          rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n        const price = rewardAsset.price?.usd || 0;\n        return (\n          new Big(reward.reward_per_day)\n            .div(new Big(10).pow(decimals))\n            .mul(365)\n            .mul(price)\n            .div(totalSupplyUsd)\n            .mul(100)\n            .toNumber() || 0\n        );\n      }\n    );\n\n    const apyReward = apyRewards.reduce(sumReducer, 0);\n\n    const borrowedFarmRewards =\n      asset.farms.find((farm) => farm.farm_id.Borrowed === tokenId)?.rewards ||\n      {};\n\n    const rewardTokensBorrow = Object.entries(borrowedFarmRewards).map(\n      ([rewardTokenId]) => rewardTokenId\n    );\n\n    const apyRewardBorrow = Object.entries(borrowedFarmRewards)\n      .map(([rewardTokenId, reward]) => {\n        const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n        const decimals =\n          rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n        const price = rewardAsset.price?.usd || 0;\n\n        if (!totalBorrowUsd) return 0;\n\n        return (\n          new Big(reward.reward_per_day)\n            .div(new Big(10).pow(decimals))\n            .mul(365)\n            .mul(price)\n            .div(totalBorrowUsd)\n            .mul(100)\n            .toNumber() || 0\n        );\n      })\n      .reduce(sumReducer, 0);\n\n    return {\n      token_id: asset.token_id,\n      symbol: asset.metadata.symbol,\n      tvlUsd: totalSupplyUsd - totalBorrowUsd,\n      apyReward,\n      apyRewardTvl: apyRewardTvl || 0,\n      apyBase,\n      rewardTokens,\n      totalSupplyUsd,\n      totalBorrowUsd,\n      apyBaseBorrow,\n      apyRewardBorrow,\n      rewardTokensBorrow,\n      ltv: asset.config.volatility_ratio,\n    };\n  });\n\n  return rewards;\n};\n\n// get account portfolio\nconst getAccount = () => {\n  if (!accountId) return null;\n  const account = Near.view(BURROW_CONTRACT, \"get_account\", {\n    account_id: accountId,\n  });\n  return account;\n};\n\nconst assets = getAssets();\n\nif (!assets) return <div />;\n\nconst rewards = getRewards(assets);\n\nif (!rewards) return <div />;\n\nconst balances = getBalances(assets);\nconst account = getAccount();\n\nconst data = {\n  assets,\n  rewards,\n  balances,\n  account,\n};\n\nif (typeof props.onLoad === \"function\") {\n  props.onLoad(data);\n}\n\nreturn <div />;\n"
    },
    "ciocan.near/widget/burrow-list": {
      "code": "const toAPY = (v) => Math.round(v * 100) / 100;\n\nconst NEAR_LOGO = `data:image/svg+xml,%3Csvg width='35' height='35' fill='none' xmlns='http://www.w3.org/2000/svg' class='MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv' focusable='false' aria-hidden='true' viewBox='0 0 35 35' style='width: 35px; height: 35px; filter: invert(100%25);'%3E%3Ccircle cx='17.5' cy='17.5' r='17.5' fill='%23fff'%3E%3C/circle%3E%3Cpath d='m24.027 9.022-4.174 6.2c-.288.422.267.934.666.578l4.107-3.578c.111-.089.266-.022.266.134v11.177c0 .156-.2.223-.288.111L12.174 8.756A2.053 2.053 0 0 0 10.552 8h-.444C8.954 8 8 8.956 8 10.133v15.734C8 27.044 8.954 28 10.131 28a2.14 2.14 0 0 0 1.82-1.022l4.173-6.2c.289-.422-.266-.934-.666-.578l-4.106 3.556c-.111.088-.267.022-.267-.134V12.467c0-.156.2-.223.289-.111l12.43 14.888c.4.49 1 .756 1.621.756h.444A2.133 2.133 0 0 0 28 25.867V10.133A2.133 2.133 0 0 0 25.869 8a2.15 2.15 0 0 0-1.842 1.022Z' fill='%23000'%3E%3C/path%3E%3C/svg%3E`;\n\nconst nFormat = (num, digits) => {\n  const lookup = [\n    { value: 1, symbol: \"\" },\n    { value: 1e3, symbol: \"k\" },\n    { value: 1e6, symbol: \"M\" },\n  ];\n  const rx = /\\.0+$|(\\.[0-9]*[1-9])0+$/;\n  var item = lookup\n    .slice()\n    .reverse()\n    .find((item) => num >= item.value);\n  return item\n    ? (num / item.value).toFixed(digits).replace(rx, \"$1\") + item.symbol\n    : \"0\";\n};\n\nconst { assets, rewards } = state;\n\nconst hasData = assets.length > 0 && rewards.length > 0;\n\nconst onLoad = (data) => {\n  State.update(data);\n};\n\nconst allAssets = hasData\n  ? assets.map((asset) => {\n      const r = rewards.find((a) => a.token_id === asset.token_id);\n      const depositApy = r.apyBase + r.apyRewardTvl + r.apyReward;\n      const borrowApy = r.apyBaseBorrow;\n      const liquidity = nFormat(asset.availableLiquidity, 2);\n      const icon = asset.metadata.icon || NEAR_LOGO;\n\n      return (\n        <tr>\n          <td>\n            <img src={icon} style={{ width: 24, marginRight: 10 }} />\n            <span>{asset.metadata.symbol}</span>\n          </td>\n          <td class=\"text-end\">{toAPY(depositApy)}%</td>\n          <td class=\"text-end\">{toAPY(borrowApy)}%</td>\n          <td class=\"text-end\">{liquidity}</td>\n        </tr>\n      );\n    })\n  : undefined;\n\nreturn (\n  <div>\n    {!hasData && (\n      <Widget src=\"ciocan.near/widget/burrow-data\" props={{ onLoad }} />\n    )}\n    <table class=\"table\">\n      <thead>\n        <tr\n          style={{\n            color: \"rgba(0, 0, 0, 0.4)\",\n          }}\n        >\n          <th scope=\"col\">Asset</th>\n          <th scope=\"col\" class=\"text-end\">\n            APY\n          </th>\n          <th scope=\"col\" class=\"text-end\">\n            APY (borrow)\n          </th>\n          <th scope=\"col\" class=\"text-end\">\n            Liquidity\n          </th>\n        </tr>\n      </thead>\n      <tbody>{allAssets}</tbody>\n    </table>\n  </div>\n);\n"
    },
    "ciocan.near/widget/burrow-portfolio": {
      "code": "let accountId = context.accountId;\n\nconst NEAR_LOGO = `data:image/svg+xml,%3Csvg width='35' height='35' fill='none' xmlns='http://www.w3.org/2000/svg' class='MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv' focusable='false' aria-hidden='true' viewBox='0 0 35 35' style='width: 35px; height: 35px; filter: invert(100%25);'%3E%3Ccircle cx='17.5' cy='17.5' r='17.5' fill='%23fff'%3E%3C/circle%3E%3Cpath d='m24.027 9.022-4.174 6.2c-.288.422.267.934.666.578l4.107-3.578c.111-.089.266-.022.266.134v11.177c0 .156-.2.223-.288.111L12.174 8.756A2.053 2.053 0 0 0 10.552 8h-.444C8.954 8 8 8.956 8 10.133v15.734C8 27.044 8.954 28 10.131 28a2.14 2.14 0 0 0 1.82-1.022l4.173-6.2c.289-.422-.266-.934-.666-.578l-4.106 3.556c-.111.088-.267.022-.267-.134V12.467c0-.156.2-.223.289-.111l12.43 14.888c.4.49 1 .756 1.621.756h.444A2.133 2.133 0 0 0 28 25.867V10.133A2.133 2.133 0 0 0 25.869 8a2.15 2.15 0 0 0-1.842 1.022Z' fill='%23000'%3E%3C/path%3E%3C/svg%3E`;\n\nif (!accountId) {\n  return <Widget src=\"ciocan.near/widget/account-signin\" />;\n}\n\nconst toAPY = (v) => Math.round(v * 100) / 100;\n\nconst shrinkToken = (value, decimals, fixed) => {\n  return new Big(value).div(new Big(10).pow(decimals)).toFixed(fixed);\n};\n\nconst { assets, rewards, account } = state;\n\nconst hasData = assets.length > 0 && rewards.length > 0 && account;\n\nconst onLoad = (data) => {\n  State.update(data);\n};\n\nconst depositedAssets = hasData\n  ? new Set([\n      ...account.supplied.map((a) => a.token_id),\n      ...account.collateral.map((a) => a.token_id),\n    ])\n  : new Set();\n\n// get portfolio deposited assets\nconst suppliedAssets = hasData\n  ? [...depositedAssets].map((depositedTokenId) => {\n      const asset = assets.find((a) => a.token_id === depositedTokenId);\n\n      const r = rewards.find((a) => a.token_id === asset.token_id);\n      const totalApy = r.apyBase + r.apyRewardTvl + r.apyReward;\n\n      const decimals = asset.metadata.decimals + asset.config.extra_decimals;\n\n      const supplied = account.supplied.find(\n        (s) => s.token_id === depositedTokenId\n      );\n\n      const depositedBalance = supplied\n        ? Number(shrinkToken(supplied.balance, decimals))\n        : 0;\n\n      const collateral = account.collateral.find(\n        (c) => c.token_id === depositedTokenId\n      );\n\n      const collateralBalance = collateral\n        ? Number(shrinkToken(collateral.balance, decimals))\n        : 0;\n\n      const totalBalance = depositedBalance + collateralBalance;\n      const usd = totalBalance * asset.price.usd;\n      const icon = asset.metadata.icon || NEAR_LOGO;\n      return (\n        <tr>\n          <td>\n            <img src={icon} style={{ width: 24, marginRight: 10 }} />\n            <span>{asset.metadata.symbol}</span>\n          </td>\n          <td class=\"text-end\">{toAPY(totalApy)}%</td>\n          <td class=\"text-end\">{totalBalance.toFixed(4)}</td>\n          <td class=\"text-end\">${usd.toFixed(2)}</td>\n        </tr>\n      );\n    })\n  : undefined;\n\n// get portfolio borrowed assets\nconst borrowedAssets = hasData\n  ? account.borrowed.map((borrowedAsset) => {\n      const asset = assets.find((a) => a.token_id === borrowedAsset.token_id);\n      const r = rewards.find((a) => a.token_id === asset.token_id);\n      const totalApy = r.apyBaseBorrow;\n\n      const decimals = asset.metadata.decimals + asset.config.extra_decimals;\n      const borrowed = Number(shrinkToken(borrowedAsset.balance, decimals));\n      const usd = borrowed * asset.price.usd;\n\n      // if (usd < 0.01) return null;\n\n      return (\n        <tr>\n          <td>\n            <img\n              src={asset.metadata.icon}\n              style={{ width: 24, marginRight: 10 }}\n            />\n            <span>{asset.metadata.symbol}</span>\n          </td>\n          <td class=\"text-end\">{toAPY(totalApy)}%</td>\n          <td class=\"text-end\">{borrowed.toFixed(4)}</td>\n          <td class=\"text-end\">${usd.toFixed(2)}</td>\n        </tr>\n      );\n    })\n  : undefined;\n\nreturn (\n  <div>\n    {!hasData && (\n      <Widget src=\"ciocan.near/widget/burrow-data\" props={{ onLoad }} />\n    )}\n    <table class=\"table\">\n      <thead>\n        <tr\n          style={{\n            color: \"rgba(0, 0, 0, 0.4)\",\n          }}\n        >\n          <th scope=\"col\">Deposited Assets</th>\n          <th scope=\"col\" class=\"text-end\">\n            APY\n          </th>\n          <th scope=\"col\" class=\"text-end\">\n            Deposited\n          </th>\n          <th scope=\"col\" class=\"text-end\">\n            $\n          </th>\n        </tr>\n      </thead>\n      <tbody>{suppliedAssets}</tbody>\n    </table>\n\n    <table class=\"table\">\n      <thead>\n        <tr\n          style={{\n            color: \"rgba(0, 0, 0, 0.4)\",\n          }}\n        >\n          <th scope=\"col\">Borrowed Assets</th>\n          <th scope=\"col\" class=\"text-end\">\n            APY\n          </th>\n          <th scope=\"col\" class=\"text-end\">\n            Borrowed\n          </th>\n          <th scope=\"col\" class=\"text-end\">\n            $\n          </th>\n        </tr>\n      </thead>\n      <tbody>{borrowedAssets}</tbody>\n    </table>\n  </div>\n);\n"
    },
    "ciocan.near/widget/burrow-rewards": {
      "code": "let accountId = context.accountId;\n\nif (!accountId) {\n  return <div />;\n}\n\nconst shrinkToken = (value, decimals, fixed) => {\n  return new Big(value).div(new Big(10).pow(decimals)).toFixed(fixed);\n};\n\nconst { assets, rewards, account } = state;\n\nconst hasData = assets.length > 0 && rewards.length > 0 && account;\n\nconst onLoad = (data) => {\n  State.update(data);\n};\n\nconst unclaimedRewardsMap = account\n  ? account.farms?.reduce((prev, curr) => {\n      for (const reward of curr.rewards) {\n        const t = prev[reward.reward_token_id];\n        if (t) {\n          prev[reward.reward_token_id] = Big(t)\n            .plus(Big(reward.unclaimed_amount))\n            .toFixed();\n        } else {\n          prev[reward.reward_token_id] = Big(reward.unclaimed_amount).toFixed();\n        }\n      }\n      return prev;\n    }, {})\n  : {};\n\nconst unclaimedRewards = Object.keys(unclaimedRewardsMap).map((id) => {\n  const asset = assets.find((a) => a.token_id === id);\n  const decimals = asset.metadata.decimals + asset.config.extra_decimals;\n  return {\n    id,\n    unclaimed: shrinkToken(unclaimedRewardsMap[id], decimals, 4),\n    symbol: asset.metadata.symbol,\n  };\n});\n\nconst handleClaimAll = () => {\n  Near.call({\n    contractName: \"contract.main.burrow.near\",\n    methodName: \"account_farm_claim_all\",\n  });\n};\n\nreturn (\n  <div>\n    {!hasData && (\n      <Widget src=\"ciocan.near/widget/burrow-data\" props={{ onLoad }} />\n    )}\n    <h6>Unclaimed rewards</h6>\n    <ul class=\"list p-0\">\n      {unclaimedRewards.map((reward) => (\n        <li class=\"list-inline-item align-middle\">\n          <span class=\"badge rounded-pill bg-light text-dark\">\n            {reward.unclaimed}\n          </span>\n          <span class=\"align-middle\">{reward.symbol}</span>\n        </li>\n      ))}\n    </ul>\n    <button type=\"button\" class=\"btn btn-light\" onClick={handleClaimAll}>\n      Claim all rewards\n    </button>\n  </div>\n);\n"
    },
    "ciocan.near/widget/burrow-repay": {
      "code": "let BURROW_CONTRACT = \"contract.main.burrow.near\";\nlet accountId = context.accountId;\n\nconst { selectedTokenId, amount, hasError, assets, rewards, account } = state;\n\nconst hasData = assets.length > 0 && rewards.length > 0;\n\nconst onLoad = (data) => {\n  State.update(data);\n};\n\nconst shrinkToken = (value, decimals) => {\n  return new Big(value).div(new Big(10).pow(decimals));\n};\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nconst formatToken = (v) => Math.floor(v * 10_000) / 10_000;\nconst toAPY = (v) => Math.round(v * 100) / 100;\n\nif (!accountId) {\n  return <Widget src=\"ciocan.near/widget/account-signin\" />;\n}\n\nconst listAssets =\n  assets &&\n  assets\n    ?.filter((a) => a.accountBalance > 0)\n    ?.map((asset) => {\n      const { token_id, metadata } = asset;\n      if (account.borrowed.map((a) => a.token_id).includes(token_id)) {\n        return (\n          <option key={token_id} value={token_id}>\n            {metadata.symbol}\n          </option>\n        );\n      }\n    });\n\nlet availableBalance = 0;\nlet apy = 0;\n\nconst getBalance = (asset) => {\n  if (!asset) return 0;\n  const { accountBalance, metadata } = asset;\n  return formatToken(shrinkToken(accountBalance, metadata.decimals).toFixed());\n};\n\nconst getApy = (asset) => {\n  if (!asset) return 0;\n  const r = rewards.find((a) => a.token_id === asset.token_id);\n  return toAPY(r.apyBaseBorrow);\n};\n\nif (selectedTokenId) {\n  const token = selectedTokenId === \"NEAR\" ? \"wrap.near\" : selectedTokenId;\n  const asset = assets.find((a) => a.token_id === token);\n  availableBalance =\n    selectedTokenId === \"NEAR\" ? nearBalance : getBalance(asset);\n  apy = getApy(asset);\n}\n\nconst storageBurrow = Near.view(BURROW_CONTRACT, \"storage_balance_of\", {\n  account_id: accountId,\n});\n\nconst storageToken = selectedTokenId\n  ? Near.view(selectedTokenId, \"storage_balance_of\", {\n      account_id: accountId,\n    })\n  : null;\n\nconst handleSelect = (e) => {\n  State.update({\n    selectedTokenId: e.target.value,\n    amount: \"\",\n    hasError: false,\n  });\n};\n\nconst handleAmount = (e) => {\n  State.update({\n    amount: Number(e.target.value),\n    selectedTokenId,\n    hasError: false,\n  });\n};\n\nconst handleRepay = () => {\n  const asset = assets.find((a) => a.token_id === selectedTokenId);\n\n  if (!selectedTokenId || !amount || hasError) return;\n\n  if (amount > availableBalance) {\n    State.update({ selectedTokenId, amount, hasError: true });\n    return;\n  }\n  const transactions = [];\n\n  const expandedAmount = expandToken(\n    amount,\n    asset.metadata.decimals + asset.config.extra_decimals\n  );\n\n  const repayTemplate = {\n    Execute: {\n      actions: [\n        {\n          Repay: {\n            max_amount: expandedAmount.toFixed(0),\n            token_id: selectedTokenId,\n          },\n        },\n      ],\n    },\n  };\n\n  const repayTransaction = {\n    contractName: selectedTokenId,\n    methodName: \"ft_transfer_call\",\n    deposit: new Big(\"1\").toFixed(),\n    gas: expandToken(300, 12),\n    args: {\n      receiver_id: BURROW_CONTRACT,\n      amount: expandedAmount.toFixed(0),\n      msg: JSON.stringify(repayTemplate),\n    },\n  };\n\n  if (storageToken?.available === \"0\" || !storageToken?.available) {\n    transactions.push({\n      contractName: selectedTokenId,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.25, 24).toFixed(),\n    });\n  }\n\n  if (storageBurrow?.available === \"0\" || !storageBurrow?.available) {\n    transactions.push({\n      contractName: BURROW_CONTRACT,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.25, 24).toFixed(),\n      gas: expandToken(140, 12),\n    });\n  }\n\n  transactions.push(repayTransaction);\n\n  Near.call(transactions);\n};\n\nreturn (\n  <div style={{ maxWidth: \"300px\" }}>\n    {!hasData && (\n      <Widget src=\"ciocan.near/widget/burrow-data\" props={{ onLoad }} />\n    )}\n    <div class=\"card-body d-grid gap-3\">\n      <div>\n        <div class=\"mb-2 text-muted\">From</div>\n        <select\n          onChange={handleSelect}\n          class=\"p-2 mb-1\"\n          style={{ width: \"100%\" }}\n        >\n          <option value=\"\">Repay an asset</option>\n          {listAssets}\n        </select>\n        <div>\n          <span class=\"badge bg-light text-dark\">\n            {availableBalance} available\n          </span>\n          <span class=\"badge bg-light text-dark\">{apy}% Borrow APY</span>\n        </div>\n      </div>\n      <div>\n        <div class=\"mb-2 text-muted\">Amount</div>\n        <input type=\"number\" value={amount} onChange={handleAmount} />\n      </div>\n      {hasError && (\n        <p class=\"alert alert-danger\" role=\"alert\">\n          Amount greater than balance\n        </p>\n      )}\n      <button\n        onClick={handleRepay}\n        style={{ background: \"#4ED58A\", borderColor: \"white\" }}\n      >\n        Repay\n      </button>\n    </div>\n  </div>\n);\n"
    },
    "ciocan.near/widget/account-signin": {
      "code": "let accountId = context.accountId;\n\nif (accountId) return <div />;\n\nreturn (\n  <div>\n    <a href=\"https://near.social\" target=\"blank\">\n      Please sign in with NEAR wallet\n    </a>\n  </div>\n);\n"
    },
    "ciocan.near/widget/Draft-1": {
      "code": "// console.log(\"state\", state);\n\nconst tokenDecimals = 18;\n\nconst chainId = state.chainId || 5;\n\nEthers.provider()\n  .getNetwork()\n  .then(({ chainId }) => {\n    State.update({ chainId });\n  });\n\nconst chainData = {\n  // mainnet\n  1: {\n    stakingContractAddress: \"0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9\",\n    coinContractAddress: \"0x4d224452801aced8b2f0aebe155379bb5d594381\",\n  },\n  // testnet (goerli)\n  5: {\n    stakingContractAddress: \"0xeF37717B1807a253c6D140Aca0141404D23c26D4\",\n    coinContractAddress: \"0x328507DC29C95c170B56a1b3A758eB7a9E73455c\",\n  },\n};\n\nconst coinContractAddress = chainData[chainId].coinContractAddress;\nconst stakingContractAddress = chainData[chainId].stakingContractAddress;\n\nconst coinContractAbi = [\n  // Read-Only Functions\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  // Write Functions\n  \"function approve(address spender, uint256 amount) nonpayable returns (bool)\",\n];\n\n// FETCH APESTAKE ABI\nconst apeStakingAbi = fetch(\n  \"https://raw.githubusercontent.com/apestakeui/ui/main/src/ApeCoinStakingAbi.json\"\n);\nif (!apeStakingAbi.ok) {\n  return \"Loading\";\n}\n\nconst stakingContractAbi = JSON.parse(apeStakingAbi.body).abi;\n\nconst ifaceCoin = new ethers.utils.Interface(coinContractAbi);\nconst ifaceStaking = new ethers.utils.Interface(stakingContractAbi);\n\nconst getApeBalance = (receiver) => {\n  const encodedData = ifaceCoin.encodeFunctionData(\"balanceOf\", [receiver]);\n\n  return Ethers.provider()\n    .call({\n      to: coinContractAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = ifaceCoin.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\nconst getStakedTotal = (receiver) => {\n  const encodedData = ifaceStaking.encodeFunctionData(\"stakedTotal\", [\n    receiver,\n  ]);\n\n  return Ethers.provider()\n    .call({\n      to: stakingContractAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = ifaceStaking.decodeFunctionResult(\n        \"stakedTotal\",\n        rawBalance\n      );\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\n// DETECT SENDER\nif (state.sender === undefined) {\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  if (accounts.length) {\n    State.update({ sender: accounts[0] });\n  }\n}\n\n// FETCH SENDER BALANCE\nif (state.balance === undefined && state.sender) {\n  Ethers.provider()\n    .getBalance(state.sender)\n    .then((balance) => {\n      State.update({\n        balance: Big(balance).div(Big(10).pow(tokenDecimals)).toFixed(2),\n      });\n    });\n}\n\n// FETCH SENDER APE BALANCE\nif (state.apeBalance === undefined && state.sender) {\n  getApeBalance(state.sender).then((apeBalance) => {\n    State.update({ apeBalance });\n  });\n}\n\n// FETCH TOTAL STAKED\nif (state.stakedTotal === undefined && state.sender) {\n  getStakedTotal(state.sender).then((stakedTotal) => {\n    State.update({ stakedTotal });\n  });\n}\n\nconst handleStake = () => {\n  console.log(\"handleStake\", state.amount);\n  if (!state.amount) return;\n\n  const amountBig = ethers.utils.parseUnits(state.amount, tokenDecimals);\n\n  const apeStakeContract = new ethers.Contract(\n    stakingContractAddress,\n    ifaceStaking,\n    Ethers.provider().getSigner()\n  );\n\n  apeStakeContract.depositSelfApeCoin(amountBig, { gasLimit: 3e4 });\n};\n\nconst handleValueChange = (e) => {\n  State.update({ amount: e.target.value });\n};\n\nreturn (\n  <div className=\"container\" style={{ maxWidth: \"600px\" }}>\n    <div className=\"row\">\n      <div className=\"col\">\n        <div>\n          <div className=\"container border py-2 mb-3\">\n            <div>APE: {state.apeBalance}</div>\n            <div>Staked total: {state.stakedTotal}</div>\n          </div>\n          <div className=\"container border py-4 mb-3 d-grid gap-3\">\n            <input type=\"number\" onChange={handleValueChange} />\n            <button onClick={handleStake}>Stake APECOIN</button>\n          </div>\n        </div>\n      </div>\n      <div className=\"col\">\n        <Web3Connect className=\"w3\" connectLabel=\"Connect with Web3\" />\n      </div>\n    </div>\n  </div>\n);\n"
    },
    "ciocan.near/widget/ape-stake": {
      "code": "console.log(\"state\", state);\n\nconst tokenDecimals = 18;\n\nconst chainId = state.chainId || 5;\n\nEthers.provider()\n  .getNetwork()\n  .then(({ chainId }) => {\n    State.update({ chainId });\n  });\n\nconst chainData = {\n  // mainnet\n  1: {\n    stakingContractAddress: \"0x5954aB967Bc958940b7EB73ee84797Dc8a2AFbb9\",\n    coinContractAddress: \"0x4d224452801aced8b2f0aebe155379bb5d594381\",\n  },\n  // testnet (goerli)\n  5: {\n    stakingContractAddress: \"0xeF37717B1807a253c6D140Aca0141404D23c26D4\",\n    coinContractAddress: \"0x328507DC29C95c170B56a1b3A758eB7a9E73455c\",\n  },\n};\n\nconst coinContractAddress = chainData[chainId].coinContractAddress;\nconst stakingContractAddress = chainData[chainId].stakingContractAddress;\n\nconst coinContractAbi = [\n  // Read-Only Functions\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \"function decimals() view returns (uint8)\",\n  \"function symbol() view returns (string)\",\n  \"function allowance(address owner, address spender) view returns (uint256)\",\n  // Write Functions\n  \"function approve(address spender, uint256 amount) nonpayable returns (bool)\",\n];\n\n// FETCH APESTAKE ABI\nconst apeStakingAbi = fetch(\n  \"https://raw.githubusercontent.com/apestakeui/ui/main/src/ApeCoinStakingAbi.json\"\n);\nif (!apeStakingAbi.ok) {\n  return \"Loading\";\n}\n\nconst stakingContractAbi = JSON.parse(apeStakingAbi.body).abi;\n\nconst ifaceCoin = new ethers.utils.Interface(coinContractAbi);\nconst ifaceStaking = new ethers.utils.Interface(stakingContractAbi);\n\nconst getApeBalance = (receiver) => {\n  const encodedData = ifaceCoin.encodeFunctionData(\"balanceOf\", [receiver]);\n\n  return Ethers.provider()\n    .call({\n      to: coinContractAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = ifaceCoin.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\nconst getStakedTotal = (receiver) => {\n  const encodedData = ifaceStaking.encodeFunctionData(\"stakedTotal\", [\n    receiver,\n  ]);\n\n  return Ethers.provider()\n    .call({\n      to: stakingContractAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = ifaceStaking.decodeFunctionResult(\n        \"stakedTotal\",\n        rawBalance\n      );\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\n// DETECT SENDER\nif (state.sender === undefined) {\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  if (accounts.length) {\n    State.update({ sender: accounts[0] });\n  }\n}\n\n// FETCH SENDER BALANCE\nif (state.balance === undefined && state.sender) {\n  Ethers.provider()\n    .getBalance(state.sender)\n    .then((balance) => {\n      State.update({\n        balance: Big(balance).div(Big(10).pow(tokenDecimals)).toFixed(2),\n      });\n    });\n}\n\n// FETCH SENDER APE BALANCE\nif (state.apeBalance === undefined && state.sender) {\n  getApeBalance(state.sender).then((apeBalance) => {\n    State.update({ apeBalance });\n  });\n}\n\n// FETCH ALLOWANCE\nconst getTokenAllowance = (receiver) => {\n  const encodedData = ifaceCoin.encodeFunctionData(\"allowance\", [\n    receiver,\n    stakingContractAddress,\n  ]);\n\n  return Ethers.provider()\n    .call({\n      to: coinContractAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = ifaceCoin.decodeFunctionResult(\n        \"allowance\",\n        rawBalance\n      )[0];\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2);\n    });\n};\n\n// FETCH ALLOWANCE\nif (state.sender && state.allowance == undefined) {\n  getTokenAllowance(state.sender).then((allowance) => {\n    State.update({ allowance });\n  });\n}\n\n// FETCH TOTAL STAKED\nif (state.stakedTotal === undefined && state.sender) {\n  getStakedTotal(state.sender).then((stakedTotal) => {\n    State.update({ stakedTotal });\n  });\n}\n\n// APPROVE TOKEN\nconst approveToken = () => {\n  const erc20 = new ethers.Contract(\n    coinContractAddress,\n    ifaceCoin,\n    Ethers.provider().getSigner()\n  );\n\n  const allowanceBig = ethers.utils.parseUnits(\n    state.allowanceUpdate,\n    tokenDecimals\n  );\n\n  erc20\n    .approve(stakingContractAddress, allowanceBig)\n    .then((transactionHash) => transactionHash.wait())\n    .then((receipt) => {\n      console.log(\"receipt\", receipt);\n    })\n    .catch((err) => {\n      console.error(err);\n    });\n};\n\nconst insufficientAllowance = Number(state.allowance) < 1;\n\nconst handleStake = () => {\n  if (insufficientAllowance) {\n    if (!state.allowanceUpdate) return;\n    approveToken();\n    return;\n  }\n\n  if (!state.amount) return;\n\n  const amountBig = ethers.utils.parseUnits(state.amount, tokenDecimals);\n  const signer = Ethers.provider().getSigner();\n\n  const apeStakeContract = new ethers.Contract(\n    stakingContractAddress,\n    ifaceStaking,\n    signer\n  );\n\n  apeStakeContract.depositSelfApeCoin(amountBig, { gasLimit: 3e6 });\n};\n\nconst handleValueChange = (e) => {\n  State.update({ amount: e.target.value });\n};\n\nconst handleAllowanceChange = (e) => {\n  State.update({ allowanceUpdate: e.target.value });\n};\n\nreturn (\n  <div className=\"container mt-4\" style={{ maxWidth: \"600px\" }}>\n    <div className=\"row\">\n      <div className=\"col\">\n        <div>\n          <div className=\"container border py-2 mb-3\">\n            <div>APE: {state.apeBalance}</div>\n            <div>Staked total: {state.stakedTotal}</div>\n          </div>\n          <div className=\"container border py-4 mb-3 d-grid gap-3\">\n            <input type=\"number\" onChange={handleValueChange} />\n            {insufficientAllowance && (\n              <div class=\"alert alert-warning\" role=\"alert\">\n                <h6>Insufficient allowance</h6>\n                <input onChange={handleAllowanceChange} />\n              </div>\n            )}\n            <button onClick={handleStake}>Stake APECOIN</button>\n          </div>\n        </div>\n      </div>\n      <div className=\"col\">\n        <Web3Connect className=\"w3\" connectLabel=\"Connect with Web3\" />\n      </div>\n    </div>\n  </div>\n);\n"
    },
    "ciocan.near/widget/zk-bridge": {
      "code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst clone = (o) => JSON.parse(JSON.stringify(o));\n\nconst { deposit, withdraw } = state;\nconst tab = !state.tab || state.tab === \"deposit\" ? \"deposit\" : \"withdraw\";\n\nconst zkAbi = fetch(\n  \"https://gist.githubusercontent.com/kcole16/3aa22a29b14ea6a1a7377b38463697ef/raw/c8a7249231ac00c7c3c9f1dc6188fbf28c262cb5/abi.json\"\n);\n\nconst erc20Abi = fetch(\n  \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n);\n\nif (!zkAbi.ok || !erc20Abi.ok) {\n  return \"\";\n}\n\nconst iface = new ethers.utils.Interface(zkAbi.body);\n\nconst chainId = state.chainId || \"testnet\";\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId: chainId === 5 ? \"testnet\" : \"mainnet\" });\n    });\n}\n\n// https://era.zksync.io/docs/dev/building-on-zksync/useful-address.html\nconst contracts = {\n  mainnet: {\n    bridge: {\n      L1ERC20BridgeProxy: \"0x57891966931Eb4Bb6FB81430E6cE0A03AAbDe063\",\n      L2ERC20Bridge: \"0x11f943b2c77b743AB90f4A0Ae7d5A4e7FCA3E102\",\n    },\n    weth: {\n      deposit: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\", // l1 token\n      withdraw: \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\", // l2 token\n    },\n    usdc: {\n      deposit: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\", // l1 token\n      withdraw: \"0x3355df6D4c9C3035724Fd0e3914dE96A5a83aaf4\", // l2 token\n    },\n  },\n  testnet: {\n    bridge: {\n      L1ERC20BridgeProxy: \"0x927DdFcc55164a59E0F33918D13a2D559bC10ce7\",\n      L2ERC20Bridge: \"0x00ff932A6d70E2B8f1Eb4919e1e09C1923E7e57b\",\n    },\n    weth: {\n      deposit: \"0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6\",\n      withdraw: undefined, // not found yet\n    },\n    usdc: {\n      deposit: \"0x07865c6e87b9f70255377e024ace6630c1eaa37f\",\n      withdraw: undefined, // not found yet\n    },\n  },\n};\n\nconst l2TxGasLimit = \"900000\";\nconst l2TxGasPerPubdataByte = \"800\";\nconst tokenDecimals = 18;\n\nconst onAction = (data) => {\n  if (!data.amount) return;\n  if (data.action === \"deposit\") handleDeposit(data);\n  if (data.action === \"withdraw\") handleWithdraw(data);\n};\n\nconst handleDeposit = (data) => {\n  console.log(\"handleDeposit\", data);\n  State.update({ isLoading: true, log: undefined, explorerLink: undefined });\n  const l1Token = contracts[chainId][data.assetId].deposit;\n  const amountBig = ethers.utils.parseUnits(data.amount, tokenDecimals);\n\n  const encodedData = iface.encodeFunctionData(\n    \"deposit(address,address,uint256,uint256,uint256,address)\",\n    [sender, l1Token, amountBig, l2TxGasLimit, l2TxGasPerPubdataByte, sender]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: contracts[chainId].bridge.L1ERC20BridgeProxy,\n      data: encodedData,\n      value: amountBig,\n      gasLimit: ethers.BigNumber.from(\"500000\"),\n    })\n    .then(() => handleApprove(data))\n    .catch((e) => {\n      console.error(\"deposit error:\", e);\n      State.update({ isLoading: false });\n    });\n};\n\nconst handleApprove = (data) => {\n  console.log(\"handleApprove\", data);\n  const contract = new ethers.Contract(\n    contracts[chainId][data.assetId].deposit,\n    erc20Abi.body,\n    Ethers.provider().getSigner()\n  );\n\n  const amountBig = ethers.utils.parseUnits(data.amount, tokenDecimals);\n\n  contract\n    .approve(contracts[chainId].bridge.L1ERC20BridgeProxy, amountBig)\n    .then((tx) => {\n      console.log(\"approved: \", tx);\n\n      State.update({\n        log: \"The TX hash is: \" + tx.hash,\n        explorerLink:\n          `https://${chainId === \"testnet\" ? \"goerli.\" : \"\"}etherscan.io/tx/` +\n          tx.hash,\n        isLoading: false,\n      });\n    })\n    .catch((e) => {\n      console.error(\"approve error:\", e);\n      State.update({ isLoading: false });\n    });\n};\n\nconst handleWithdraw = (data) => {\n  console.log(\"handleWithdraw\", data);\n  State.update({ isLoading: true, log: undefined, explorerLink: undefined });\n  const l2Token = contracts[chainId][data.assetId].withdraw;\n  const amountBig = ethers.utils.parseUnits(data.amount, tokenDecimals);\n\n  const encodedData = iface.encodeFunctionData(\n    \"finalizeWithdrawal(address,address,uint256,uint256,uint256,address)\",\n    [sender, l2Token, amountBig, l2TxGasLimit, l2TxGasPerPubdataByte, sender]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: contracts[chainId].bridge.L2ERC20Bridge,\n      data: encodedData,\n      value: amountBig,\n      gasLimit: ethers.BigNumber.from(\"500000\"),\n    })\n    .then((d) => {\n      console.log(\"d\", d);\n    })\n    .catch((e) => {\n      console.error(\"withdraw error:\", e);\n      State.update({ isLoading: false });\n    });\n};\n\nconst getTokenBalance = (sender, tokenAddress, callback) => {\n  if (!sender || !tokenAddress) return;\n  const erc20Abi = [\"function balanceOf(address) view returns (uint256)\"];\n  const iface = new ethers.utils.Interface(erc20Abi);\n  const encodedData = iface.encodeFunctionData(\"balanceOf\", [sender]);\n  Ethers.provider()\n    .call({\n      to: tokenAddress,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n      const balance = Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n      if (callback) callback(balance);\n    });\n};\n\n// FETCH SENDER ETH BALANCE\nif (sender) {\n  Ethers.provider()\n    .getBalance(sender)\n    .then((balance) => {\n      // console.log(\n      //   \"balance of eth:\",\n      //   Big(balance).div(Big(10).pow(tokenDecimals)).toFixed(4)\n      // );\n    });\n}\n\ninitState({\n  isLoading: false,\n  deposit: {\n    network: {\n      id: \"l1\",\n      name: \"Ethereum\",\n    },\n    assets: [\n      {\n        id: \"weth\",\n        name: \"wETH\",\n        selected: false,\n        balance: \"0.00\",\n      },\n      {\n        id: \"usdc\",\n        name: \"USDC\",\n        selected: true,\n        balance: \"0.00\",\n      },\n    ],\n  },\n  withdraw: {\n    network: {\n      id: \"l2\",\n      name: \"zkSync Era\",\n    },\n    assets: [\n      {\n        id: \"weth\",\n        name: \"wETH\",\n        selected: false,\n        balance: \"0.00\",\n      },\n      {\n        id: \"usdc\",\n        name: \"USDC\",\n        selected: true,\n        balance: \"0.00\",\n      },\n    ],\n  },\n  amount: \"0.0\",\n});\n\n// update token balances\n// l1\ngetTokenBalance(sender, contracts[chainId].weth.deposit, (balance) => {\n  if (!deposit) return;\n  const cloned = clone(deposit);\n  cloned.assets[0].balance = balance;\n  State.update({ deposit: cloned });\n});\n\ngetTokenBalance(sender, contracts[chainId].usdc.deposit, (balance) => {\n  if (!deposit) return;\n  const cloned = clone(deposit);\n  cloned.assets[1].balance = balance;\n  State.update({ deposit: cloned });\n});\n\n//l2;\ngetTokenBalance(sender, contracts[chainId].weth.withdraw, (balance) => {\n  if (!withdraw) return;\n  const cloned = clone(withdraw);\n  cloned.assets[0].balance = balance;\n  State.update({ withdraw: cloned });\n});\n\ngetTokenBalance(sender, contracts[chainId].usdc.withdraw, (balance) => {\n  if (!withdraw || !contracts[chainId].usdc.withdraw) return;\n  const cloned = clone(withdraw);\n  cloned.assets[1].balance = balance;\n  State.update({ withdraw: cloned });\n});\n\nconst onTabChange = (tab) => {\n  // console.log(\"onTabChange\", deposit, withdraw);\n  State.update({ deposit: clone(withdraw), withdraw: clone(deposit), tab });\n};\n\nreturn (\n  <Widget\n    src=\"ciocan.near/widget/bridge-ui\"\n    props={{ ...state, onTabChange, onAction, title: \"zkBridge\" }}\n  />\n);\n"
    },
    "ciocan.near/widget/bridge-ui-old": {
      "code": "/*\n// the shape of props data\n{\n  \"isLoading\": true,\n  \"log\": \"The TX hash is: 0x2c5d223e47ecd9ac68fbdcd3eeb2bc4615ce6f7209d295104131c1440056497e Etherscan\",\n  \"explorerLink\": \"https://etherscan.io/tx/123\",\n  \"title\": \"zkBridge\",\n  \"deposit\": {\n    \"network\": {\n      \"id\": \"eth-testnet\",\n      \"name\": \"Ethereum Goerli\"\n    },\n    \"assets\": [\n      {\n        \"id\": \"eth\",\n        \"name\": \"ETH\",\n        \"balance\": \"123.22\"\n      },\n      {\n        \"id\": \"usdc\",\n        \"value\": \"USDC\",\n        \"selected\": true,\n        \"balance\": \"42.00\"\n      }\n    ]\n  },\n  \"withdraw\": {\n    \"network\": {\n      \"id\": \"zksync-testnet\",\n      \"name\": \"zkSync Era Testnet\"\n    },\n    \"assets\": [\n      {\n        \"id\": \"eth\",\n        \"name\": \"ETH\",\n        \"balance\": \"0.123\"\n      },\n      {\n        \"id\": \"usdc\",\n        \"name\": \"USDC\",\n        \"selected\": true,\n        \"balance\": \"0.42\"\n      }\n    ]\n  },\n  \"amount\": \"0.1\"\n}\n*/\n\nconst {\n  deposit,\n  withdraw,\n  onTabChange,\n  onAction,\n  title,\n  isLoading,\n  log,\n  explorerLink,\n} = props;\nconst { action, amount, selectedAsset } = state;\nconst { assets } = deposit;\n\nconst isDeposit = !action || action === \"deposit\";\nconst actionTitle = isDeposit ? \"Deposit\" : \"Withdraw\";\n\nif (assets && !selectedAsset) {\n  initState({\n    selectedAsset: assets.find((a) => a.selected) || assets?.[0],\n  });\n}\n\nconst selectedAssetWithdraw = selectedAsset\n  ? withdraw?.assets?.find((a) => a.id === selectedAsset.id)\n  : undefined;\n\nconst handleAction = () => {\n  if (onAction)\n    onAction({\n      networkId: deposit.network.id,\n      amount,\n      assetId: selectedAsset.id,\n      action: isDeposit ? \"deposit\" : \"withdraw\",\n    });\n};\n\nconst handleMax = () => {\n  State.update({ amount: selectedAsset.balance });\n};\n\nconst handleAmountChange = (e) => {\n  State.update({ amount: e.target.value });\n};\n\nconst handleAssetChange = (e) => {\n  State.update({ selectedAsset: assets?.find((a) => a.id === e.target.value) });\n};\n\nconst handleTabChange = (tab) => {\n  if (isDeposit && tab === \"deposit\") return;\n  if (!isDeposit && tab === \"withdraw\") return;\n  State.update({ action: tab, amount: 0 });\n  if (onTabChange) onTabChange(tab);\n};\n\nconst Container = styled.div`\n    max-width: 400px;\n    width: 100%;\n    margin: 0 auto;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    border: 1px solid gray;\n    padding-top: 1rem;\n    border-radius: 0.5rem;\n    margin-top: 1rem;\n\n    * {\n        font-family: 'Inter custom',sans-serif;\n    }\n\n    background: white;\n    color: black;\n\n    .title {\n      margin-top: 8px;\n    }\n\n    .actionTabs {\n      border: 1px solid black;\n      height: 38px;\n      label {\n        color: gray;\n\n        &:hover {\n          color: black;\n        }\n      }\n    }\n\n    .action {\n      background: black;\n      color: white;\n    }\n\n    .balance {\n      input {\n        height: 38px;\n        background: #f5f6fd;\n        color: black;\n        border: 1px solid black;\n      }\n      button {\n        height: 38px;\n        background: #f5f6fd;\n        color: black;\n      }\n    }\n\n    .assets {\n      select {\n        background: #f5f6fd;\n        color: black;\n      }\n    }\n`;\n\nreturn (\n  <Container>\n    <div className=\"d-flex gap-4 align-items-center mb-3 justify-content-center\">\n      <h5 className=\"title\">{title || \"Bridge\"}</h5>\n      <div className=\"actionTabs btn-group\" role=\"group\" aria-label=\"Deposit\">\n        <input\n          id=\"deposit\"\n          type=\"radio\"\n          className=\"btn-check\"\n          name=\"btnradioaction\"\n          autocomplete=\"off\"\n          checked={isDeposit}\n          onClick={() => handleTabChange(\"deposit\")}\n        />\n        <label className=\"btn btn-outline-primary\" for=\"deposit\">\n          Deposit\n        </label>\n        <input\n          id=\"withdraw\"\n          type=\"radio\"\n          className=\"btn-check\"\n          name=\"btnradioaction\"\n          autocomplete=\"off\"\n          checked={!isDeposit}\n          onClick={() => handleTabChange(\"withdraw\")}\n        />\n        <label className=\"btn btn-outline-primary\" for=\"withdraw\">\n          Withdraw\n        </label>\n      </div>\n    </div>\n    <div className=\"border border-secondary border-bottom-0 border-light\" />\n    <div className=\"p-4\">\n      <div className=\"d-flex justify-content-between\">\n        <div className=\"assets d-flex flex-column gap-2\">\n          <span>{deposit.network.name}</span>\n          <select\n            className=\"form-select\"\n            aria-label=\"select asset\"\n            onChange={handleAssetChange}\n          >\n            {assets &&\n              assets.map((asset) => (\n                <option value={asset.id} selected={asset.selected}>\n                  {asset.name}\n                </option>\n              ))}\n          </select>\n        </div>\n        <div className=\"d-flex flex-column gap-2\">\n          <div className=\"d-flex justify-content-between\">\n            <span>Balance: {selectedAsset.balance}</span>\n          </div>\n          <div className=\"balance input-group\">\n            <input\n              style={{ maxWidth: \"120px\" }}\n              type=\"number\"\n              min=\"0\"\n              step=\"0.1\"\n              defaultValue={props.amount}\n              value={amount}\n              placeholder=\"0.00\"\n              onChange={handleAmountChange}\n            />\n            <button className=\"btn btn-light btn-sm\" onClick={handleMax}>\n              max\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div className=\"border border-secondary border-bottom-0 border-light\" />\n    <div className=\"p-4 d-flex justify-content-between\">\n      <div>{withdraw.network.name}</div>\n      <div>Balance: {selectedAssetWithdraw.balance}</div>\n    </div>\n    <div className=\"border border-secondary border-bottom-0 border-light\" />\n    <div className=\"p-4 d-grid gap-3\">\n      <button\n        className=\"action btn btn-primary\"\n        onClick={handleAction}\n        disabled={isLoading}\n      >\n        {isLoading ? \"Loading...\" : actionTitle}\n      </button>\n      {log && (\n        <div className=\"alert alert-success\" role=\"alert\">\n          <div className=\"text-truncate\" style={{ maxWidth: 300 }}>\n            {log}\n          </div>\n          <a href={explorerLink} className=\"alert-link\" target=\"_blank\">\n            Etherscan\n          </a>\n        </div>\n      )}\n    </div>\n  </Container>\n);\n"
    },
    "ciocan.near/widget/zkevm-bridge-ui": {
      "code": "const Layout = styled.div`\n  position: relative;\n  width: 314px;\n  min-height: 412px;\n  background-color: #151718;\n  border-radius: 14px;\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 24px;\n\n  .container {\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    padding: 0;\n  }\n\n  .container-button {\n    position: relative;\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 10px;\n    line-height: 12px;\n    cursor: pointer;\n  }\n\n  .separator {\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin-left: 8px;\n    margin-right: 8px;\n  }\n\n  .info {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 400;\n    font-size: 10px;\n    line-height: 12px;\n    list-style: none;\n    padding: 0 8px 0 8px;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    color: #fff;\n\n    li {\n      display: flex;\n      justify-content: space-between;\n    }\n\n    .value {\n      color: #BA90FF;\n      font-weight: 600;\n    }\n  }\n`;\n\nconst ContainerNetwork = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  margin-left: 16px;\n\n  .label {\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 8px;\n    line-height: 10px;\n    color: #fff;\n  }\n`;\n\nconst NetworkSelectorButton = styled.button`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 4px 8px 4px 4px;\n  gap: 4px;\n\n  height: 24px;\n  outline: none;\n  border: none;\n  position: relative;\n\n  background: #2d2f30;\n  border-radius: 12px;\n\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 10px;\n  line-height: 12px;\n\n  color: #FFFFFF;\n`;\n\nconst NetworkList = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-radius: 12px;\n  width: 145px;\n  background: #2d2f30;\n  z-index: 10;\n  box-shadow: inset 0px 0px 0px 1px #999;\n\n  ul {\n    display: flex;\n    flex-direction: column;\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    border-radius: 12px;\n  }\n\n  li {\n    display: flex;\n    justify-content: flex-start;\n    align-items: center;\n    padding: 4px 8px 4px 4px;\n    gap: 4px;\n    flex: 1;\n    width: 100%;\n    color: #fff;\n\n    &:hover {\n      color: #ccc;\n    }\n  }\n`;\n\nconst CloseButton = styled.button`\n  color: white;\n  background: none;\n  float: right;\n  margin-left: 12px;\n`;\n\nconst caretSvg = (\n  <svg width=\"6\" height=\"4\" viewBox=\"0 0 6 4\" fill=\"none\">\n    <path\n      d=\"M4.99998 1L2.99999 3L1 1\"\n      stroke=\"white\"\n      stroke-width=\"1.21738\"\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n    />\n  </svg>\n);\n\nconst TokenContainer = styled.div`\n  display: flex;\n  align-items: center;\n  padding: 16px;\n  gap: 12px;\n  position: relative;\n\n  width: 100%;\n\n  background: #2d2f30;\n  border-radius: 12px;\n\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 10px;\n  line-height: 12px;\n\n  color: #FFFFFF;\n\n  input::-webkit-outer-spin-button,\n  input::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n\n  input[type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n\n  h3 {\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 8px;\n    line-height: 10px;\n    color: rgba(255, 255, 255, 0.6);\n  }\n\n  .token-container {\n    display: flex;\n    flex-direction: column;\n    gap: 0;\n  }\n\n  .input-container {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n    justify-content: flex-end;\n    flex: 1;\n\n    .usd-value {\n      text-align: right;\n    }\n  }\n`;\n\nconst TokenSelector = styled.button`\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 16px;\n  line-height: 19px;\n  color: #FFFFFF;\n  background: none;\n  border: none;\n  padding: 0;\n  margin: 0;\n`;\n\nconst Input = styled.input`\n  background: none;\n  color: #fff;\n  text-align: right;\n  border: none;\n  outline: none;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 16px;\n  line-height: 19px;\n  width: 100%;\n`;\n\nconst ToNetworkContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 4px 8px 4px 4px;\n  gap: 4px;\n\n  height: 24px;\n  outline: none;\n  border: none;\n  position: relative;\n\n  background: #2d2f30;\n  border-radius: 12px;\n\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 10px;\n  line-height: 12px;\n\n  color: #FFFFFF;\n`;\n\nconst ActionButton = styled.button`\n  background: #8247E5;\n  border-radius: 4px;\n  border: 0;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 14px;\n  line-height: 17px;\n  color: #fff;\n  padding: 12px;\n`;\n\nconst Alert = styled.div`\n  position: absolute;\n  color: red;\n  background: #fff;\n  z-index: 20;\n  padding: 8px;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 12px;\n`;\n\nconst Dialog = styled.div`\n  position: absolute;\n  right: 32px;\n  left: 32px;\n  top: 25%;\n  background: #2d2f30;\n  z-index: 10;\n  box-shadow: inset 0px 0px 0px 1px #999;\n  border-radius: 12px;\n  padding: 16px; 8px;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 14px;\n\n  ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n  }\n\n  li {\n    display: flex;\n    justify-content: space-between;\n    cursor: pointer;\n    color: #fff;\n\n    &:hover {\n      color: #ccc;\n    }\n  }\n\n  .token {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n  }\n\n`;\n\nconst tokens = props.tokens ?? [\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n];\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst networks = {\n  1: \"Ethereum Mainnet\",\n  5: \"Ethereum Goerli\",\n  1101: \"Polygon zkEvm\",\n  1442: \"Polygon zkEvm Goerli\",\n};\n\nconst coinsMap = {\n  ethereum: \"ETH\",\n  \"usd-coin\": \"USDC\",\n  \"matic-network\": \"MATIC\",\n  dai: \"DAI\",\n  uniswap: \"UNI\",\n};\n\nState.init({\n  selectedToken: \"ETH\",\n  isNetworkSelectOpen: false,\n  isTokenDialogOpen: false,\n  amount: 0,\n  balances: {},\n  prices: {},\n  isToastOpen: false,\n});\n\nconst {\n  isNetworkSelectOpen,\n  chainId,\n  selectedToken,\n  isTokenDialogOpen,\n  amount,\n  balances,\n  prices,\n} = state;\n\nconst selectedNetwork = chainId === 1 || chainId === 5 ? \"ethereum\" : \"polygon\";\n\nconst isTestnet = chainId === 5 || chainId === 1442;\nconst isMainnet = chainId === 1 || chainId === 1101;\n\nconst walletChains = {\n  1442: {\n    chainId: `0x5a2`,\n    chainName: \"zkEVM Testnet\",\n    nativeCurrency: {\n      name: \"Ethereum\",\n      symbol: \"ETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://rpc.public.zkevm-test.net/\"],\n    blockExplorerUrls: [\"https://testnet-zkevm.polygonscan.com/\"],\n  },\n  1101: {\n    chainId: `0x44d`,\n    chainName: \"zkEVM Mainnet\",\n    nativeCurrency: {\n      name: \"Ethereum\",\n      symbol: \"ETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://zkevm-rpc.com\"],\n    blockExplorerUrls: [\"https://zkevm.polygonscan.com/\"],\n  },\n};\n\nconst switchNetwork = (chainId) => {\n  Ethers.provider()\n    .send(\"wallet_switchEthereumChain\", [\n      { chainId: `0x${chainId.toString(16)}` },\n    ])\n    .catch((err) => {\n      if (err.code === 4902) {\n        Ethers.provider()\n          .send(\"wallet_addEthereumChain\", [walletChains[chainId]])\n          .then(() => {\n            Ethers.provider().send(\"wallet_switchEthereumChain\", [\n              { chainId: `0x${chainId.toString(16)}` },\n            ]);\n          });\n      }\n    });\n};\n\nconst coins = Object.keys(coinsMap);\nconst pricesUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${coins.join(\n  \",\"\n)}&vs_currencies=usd`;\n\nif (!prices[selectedToken]) {\n  asyncFetch(pricesUrl).then((res) => {\n    if (!res.ok) return;\n    const prices = {};\n    coins.forEach((coin) => (prices[coinsMap[coin]] = res.body[coin].usd));\n    State.update({ prices });\n  });\n}\n\nconst updateBalance = (token) => {\n  const { address, decimals, symbol } = token;\n\n  // if (state.balances[symbol]) {\n  //   return;\n  // }\n\n  if (symbol === \"ETH\") {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balanceBig) => {\n        const adjustedBalance = ethers.utils.formatEther(balanceBig);\n        State.update({\n          balances: {\n            ...state.balances,\n            [symbol]: Number(adjustedBalance).toFixed(4),\n          },\n        });\n      });\n  } else {\n    const erc20Abi = [\"function balanceOf(address) view returns (uint256)\"];\n    const tokenContract = new ethers.Contract(\n      address,\n      erc20Abi,\n      Ethers.provider()\n    );\n    tokenContract.balanceOf(sender).then((balanceBig) => {\n      const adjustedBalance = ethers.utils.formatUnits(balanceBig, decimals);\n      State.update({\n        balances: {\n          ...state.balances,\n          [symbol]: Number(Number(adjustedBalance).toFixed(4)),\n        },\n      });\n    });\n  }\n};\n\ntokens.filter((t) => t.chainId === chainId).map(updateBalance);\n\nconst changeNetwork = (network) => {\n  console.log(network);\n  if (isTestnet) {\n    if (network === \"polygon\") {\n      switchNetwork(1442);\n    } else {\n      switchNetwork(5);\n    }\n  } else {\n    if (network === \"polygon\") {\n      switchNetwork(1101);\n    } else {\n      switchNetwork(1);\n    }\n  }\n  State.update({ isNetworkSelectOpen: false, selectedNetwork: network });\n};\n\nconst openNetworkList = () => {\n  State.update({ isNetworkSelectOpen: true, isTokenDialogOpen: false });\n};\n\nconst isCorrectNetwork = Object.keys(networks)\n  .map((n) => Number(n))\n  .includes(chainId);\n\nconst getFromNetworkLabel = () => {\n  switch (selectedNetwork) {\n    case \"ethereum\":\n      return isMainnet ? networks[1] : networks[5];\n    case \"polygon\":\n      return isMainnet ? networks[1101] : networks[1442];\n    default:\n      return \"unknown\";\n  }\n};\n\nconst getToNetworkLabel = () => {\n  switch (selectedNetwork) {\n    case \"ethereum\":\n      return isMainnet ? networks[1101] : networks[1442];\n    case \"polygon\":\n      return isMainnet ? networks[1] : networks[5];\n    default:\n      return \"unknown\";\n  }\n};\n\nconst getToken = (tokenSymbol) =>\n  tokens\n    .filter(\n      (t) =>\n        t.chainId ===\n        (isMainnet\n          ? selectedNetwork === \"ethereum\"\n            ? 1\n            : 1101\n          : selectedNetwork === \"ethereum\"\n          ? 5\n          : 1442)\n    )\n    .find((t) => t.symbol === tokenSymbol);\n\nconst updateToken = (tokenSymbol) => {\n  State.update({ selectedToken: tokenSymbol, isTokenDialogOpen: false });\n\n  const { onUpdateToken } = props;\n  if (onUpdateToken) {\n    const token = getToken(tokenSymbol);\n    onUpdateToken({ amount, token, network: selectedNetwork });\n  }\n};\n\nconst openTokenDialog = () => {\n  State.update({ isTokenDialogOpen: true });\n};\n\nconst changeAmount = (e) => {\n  const amount = Number(e.target.value);\n  State.update({ amount });\n\n  const { onChangeAmount } = props;\n  if (onChangeAmount) {\n    const token = getToken(selectedToken);\n    onChangeAmount({ amount, token, network: selectedNetwork });\n  }\n};\n\nconst onOpenChange = (v) => {\n  State.update({\n    isToastOpen: false,\n  });\n};\n\nconst handleConfirm = () => {\n  console.log(state);\n  const isValidAmount = amount > 0 && amount < balances[selectedToken];\n\n  if (!isValidAmount) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid amount\",\n      description: \"Amount should be less than token balance\",\n    });\n    return;\n  }\n\n  const isPolygonNetwork = chainId === 1101 || chainId === 1442;\n  if (selectedNetwork === \"ethereum\" && isPolygonNetwork) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid network\",\n      description: \"Please switch to polygon zkevm network\",\n    });\n    return;\n  }\n\n  if (selectedNetwork === \"polygon\" && !isPolygonNetwork) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid network\",\n      description: \"Please switch to ethereum network\",\n    });\n    return;\n  }\n\n  const { onConfirm } = props;\n  if (onConfirm) {\n    const token = getToken(selectedToken);\n    onConfirm({ amount, token, network: selectedNetwork });\n  }\n};\n\nconst networkList = isMainnet ? [1, 1101] : [5, 1442];\nconst token = tokens.find((t) => t.symbol === selectedToken);\n\nconst { isToastOpen, variant, title, description } = state;\n\nconsole.log(state);\n\nreturn (\n  <Layout>\n    <div class=\"container\">\n      {!isCorrectNetwork && (\n        <Alert>Please switch to Ethereum or Polygon zkEVM</Alert>\n      )}\n      <ContainerNetwork>\n        <span class=\"label\">FROM</span>\n        <div class=\"container-button\">\n          <NetworkSelectorButton onClick={openNetworkList}>\n            {selectedNetwork === \"ethereum\" ? (\n              <img\n                style={{ width: \"16px\" }}\n                src=\"https://assets.coingecko.com/coins/images/279/small/ethereum.png\"\n              />\n            ) : (\n              <img\n                style={{ width: \"16px\" }}\n                src=\"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\"\n              />\n            )}\n            <span>{getFromNetworkLabel()}</span>\n            {caretSvg}\n          </NetworkSelectorButton>\n          {isNetworkSelectOpen && (\n            <NetworkList>\n              <ul>\n                <li onClick={(e) => changeNetwork(\"ethereum\")}>\n                  <img\n                    style={{ width: \"16px\" }}\n                    src=\"https://assets.coingecko.com/coins/images/279/small/ethereum.png\"\n                  />\n                  <span>{networks[networkList[0]]}</span>\n                </li>\n                <li onClick={(e) => changeNetwork(\"polygon\")}>\n                  <img\n                    style={{ width: \"16px\" }}\n                    src=\"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\"\n                  />\n                  <span>{networks[networkList[1]]}</span>\n                </li>\n              </ul>\n            </NetworkList>\n          )}\n        </div>\n      </ContainerNetwork>\n      <TokenContainer>\n        <img style={{ width: \"32px\" }} src={token?.logoURI} />\n        <div class=\"token-container\">\n          <h3>SEND -&gt;</h3>\n          <TokenSelector disabled={!isCorrectNetwork} onClick={openTokenDialog}>\n            <span>{selectedToken}</span>\n            {caretSvg}\n          </TokenSelector>\n        </div>\n        <div class=\"input-container\">\n          <Input placeholder=\"0\" type=\"number\" onChange={changeAmount} />\n          <span class=\"usd-value\">${prices[selectedToken] * amount}</span>\n        </div>\n      </TokenContainer>\n    </div>\n    <div class=\"container\">\n      <ContainerNetwork>\n        <span class=\"label\">TO</span>\n        <ToNetworkContainer>\n          {selectedNetwork === \"polygon\" ? (\n            <img\n              style={{ width: \"16px\" }}\n              src=\"https://assets.coingecko.com/coins/images/279/small/ethereum.png\"\n            />\n          ) : (\n            <img\n              style={{ width: \"16px\" }}\n              src=\"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\"\n            />\n          )}\n          <span>{getToNetworkLabel()}</span>\n        </ToNetworkContainer>\n      </ContainerNetwork>\n      <TokenContainer>\n        <img style={{ width: \"32px\" }} src={token?.logoURI} />\n        <div class=\"token-container\">\n          <h3>-&gt; RECEIVE</h3>\n          <TokenSelector>\n            <span>{selectedToken}</span>\n          </TokenSelector>\n        </div>\n        <div class=\"input-container\">\n          <Input type=\"number\" readOnly value={amount} />\n          <span class=\"usd-value\">${prices[selectedToken] * amount}</span>\n        </div>\n      </TokenContainer>\n    </div>\n    <div class=\"separator\" />\n    <ul class=\"info\">\n      <li>\n        <span>Rate</span>\n        <span class=\"value\">\n          1 {selectedToken} = ${prices[selectedToken]}\n        </span>\n      </li>\n    </ul>\n    <ActionButton onClick={handleConfirm} disabled={!isCorrectNetwork}>\n      Confirm\n    </ActionButton>\n    {isTokenDialogOpen && (\n      <Dialog>\n        <CloseButton onClick={() => State.update({ isTokenDialogOpen: false })}>\n          x\n        </CloseButton>\n        <ul>\n          {tokens\n            .filter((t) => t.chainId === chainId)\n            .map((token) => {\n              const { symbol, logoURI } = token;\n              return (\n                <li key={symbol} onClick={() => updateToken(symbol)}>\n                  <div class=\"token\">\n                    <img style={{ width: \"16px\" }} src={logoURI} />\n                    <span>{symbol}</span>\n                  </div>\n                  <span>{state.balances[symbol] ?? \"-\"}</span>\n                </li>\n              );\n            })}\n        </ul>\n      </Dialog>\n    )}\n    <Widget\n      src=\"ciocan.near/widget/toast\"\n      props={{ open: isToastOpen, variant, title, description, onOpenChange }}\n    />\n  </Layout>\n);\n"
    },
    "ciocan.near/widget/zkevm-bridge": {
      "code": "const Container = styled.div`\n  display: flex;\n  gap: 8px;\n\n  .side {\n    margin-top: 20px;\n  }\n\n  .w3button button {\n    background-color: #854ce6;\n    color: white;\n    border: none;\n    border-radius: 30px;\n    padding: 12px 15px;\n  }\n`;\n\nconst Layout = styled.div`\n  display: flex;\n  flex-direction: column;\n  .title {\n    margin-left: 20px;\n    color: #666;\n  }\n`;\n\nconst tokens = [\n  // eth testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x4701Aa9471d7bfAc765D87dcb1Ea6BB23AD32733\",\n    chainId: 5,\n    symbol: \"MATIC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\",\n  },\n  {\n    address: \"0xd35cceead182dcee0f148ebac9447da2c4d449c4\",\n    chainId: 5,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0xD7E55eB808693D5Ff81a3391c59886C7E0449f35\",\n    chainId: 5,\n    symbol: \"DAI\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/9956/small/4943.png\",\n  },\n  {\n    address: \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\",\n    chainId: 5,\n    symbol: \"UNI\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/12504/small/uniswap-uni.png\",\n  },\n  // eth mainnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0\",\n    chainId: 1,\n    symbol: \"MATIC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\",\n  },\n  {\n    address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n    chainId: 1,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\",\n    symbol: \"DAI\",\n    decimals: 18,\n    chainId: 1,\n    logoURI: \"https://assets.coingecko.com/coins/images/9956/small/4943.png\",\n  },\n  {\n    address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n    chainId: 1,\n    symbol: \"USDT\",\n    decimals: 6,\n    logoURI: \"https://assets.coingecko.com/coins/images/325/small/Tether.png\",\n  },\n  {\n    address: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\",\n    chainId: 1,\n    symbol: \"WBTC\",\n    decimals: 8,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/7598/small/wrapped_bitcoin_wbtc.png\",\n  },\n  // zkevm testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1442,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x8Ba0a934ef4C24e475C78072cCa3Ed306c1aBaDD\",\n    chainId: 1442,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0x378588D64A464d61c646e5e86F4DA5277e65802C\",\n    chainId: 1442,\n    symbol: \"UNI\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/12504/small/uniswap-uni.png\",\n  },\n  // zkevm assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1101,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0xa2036f0538221a77A3937F1379699f44945018d0\",\n    chainId: 1101,\n    symbol: \"MATIC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\",\n  },\n  {\n    address: \"0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\",\n    chainId: 1101,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0x1E4a5963aBFD975d8c9021ce480b42188849D41d\",\n    chainId: 1101,\n    symbol: \"USDT\",\n    decimals: 6,\n    logoURI: \"https://assets.coingecko.com/coins/images/325/small/Tether.png\",\n  },\n  {\n    address: \"0xC5015b9d9161Dca7e18e32f6f25C4aD850731Fd4\",\n    chainId: 1101,\n    symbol: \"DAI\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/9956/small/Badge_Dai.png\",\n  },\n  {\n    address: \"0xEA034fb02eB1808C2cc3adbC15f447B93CbE08e1\",\n    chainId: 1101,\n    symbol: \"WBTC\",\n    decimals: 8,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/7598/small/wrapped_bitcoin_wbtc.png\",\n  },\n];\n\nconst MAX_AMOUNT =\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\nState.init({\n  gasLimit: ethers.BigNumber.from(\"300000\"),\n  isToastOpen: false,\n});\n\nconst {\n  chainId,\n  name,\n  isContractAllowedToSpendToken,\n  variant,\n  title,\n  description,\n  isToastOpen,\n} = state;\nconst isMainnet = chainId === 1 || chainId === 1101;\n\nconst onOpenChange = (v) => {\n  State.update({\n    isToastOpen: false,\n  });\n};\n\nconst BRIDGE_CONTRACT_ADDRESS = isMainnet\n  ? \"0x2a3DD3EB832aF982ec71669E178424b10Dca2EDe\"\n  : \"0xF6BEEeBB578e214CA9E23B0e9683454Ff88Ed2A7\";\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"destinationNetwork\", type: \"uint32\" },\n      { internalType: \"address\", name: \"destinationAddress\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n      { internalType: \"address\", name: \"token\", type: \"address\" },\n      { internalType: \"bool\", name: \"forceUpdateGlobalExitRoot\", type: \"bool\" },\n      { internalType: \"bytes\", name: \"permitData\", type: \"bytes\" },\n    ],\n    name: \"bridgeAsset\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nconst updateGasLimit = (props) => {\n  console.log(\"updateGasLimit\", props);\n  const { amount, token, network } = props;\n  if (network !== \"ethereum\") return;\n  const amountBig = ethers.utils.parseUnits(amount.toString(), token.decimals);\n\n  const bridgeContract = new ethers.Contract(\n    BRIDGE_CONTRACT_ADDRESS,\n    bridgeAbi,\n    Ethers.provider().getSigner()\n  );\n  bridgeContract.estimateGas\n    .bridgeAsset(1, sender, amountBig, token.address, true, \"0x\")\n    .then((data) => {\n      console.log(\"gasLimit\", data);\n    })\n    .catch((e) => {\n      console.log(\"gasLimit error\", e);\n    });\n};\n\nconst handleBridge = (props) => {\n  console.log(\"handleBridge\", props);\n  const { amount, token, network, permit } = props;\n  const networkId = network === \"ethereum\" ? 1 : 0;\n\n  const amountBig = ethers.utils.parseUnits(amount.toString(), token.decimals);\n  // const permitData = permit || \"0x\";\n  const permitData = \"0x\";\n\n  const encodedData = bridgeIface.encodeFunctionData(\n    \"bridgeAsset(uint32,address,uint256,address,bool,bytes)\",\n    [networkId, sender, amountBig, token.address, true, permitData]\n  );\n\n  updateGasLimit(props);\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: BRIDGE_CONTRACT_ADDRESS,\n      data: encodedData,\n      value: token.symbol === \"ETH\" ? amountBig : \"0\",\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n      if (!e.code) {\n        State.update({\n          isToastOpen: true,\n          variant: \"success\",\n          title: \"Asset bridged\",\n          description:\n            \"Please allow a few seconds and press the 'refresh list' button\",\n        });\n      }\n    });\n};\n\nconst setName = (token) => {\n  const abi = [\"function name() external view returns (string)\"];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider()\n  );\n  erc20contract\n    .name()\n    .then((name) => {\n      State.update({ name });\n    })\n    .catch((e) => {\n      console.log(\"name error\", e);\n    });\n};\n\nconst setIsContractAllowedToSpendToken = ({ token, amount }) => {\n  if (!amount) return;\n  const abi = [\n    \"function allowance(address owner, address spender) external view returns (uint256)\",\n  ];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider()\n  );\n\n  erc20contract\n    .allowance(sender, BRIDGE_CONTRACT_ADDRESS)\n    .then((data) => {\n      const allowance = Number(ethers.utils.formatUnits(data, token.decimals));\n      State.update({\n        isContractAllowedToSpendToken: allowance >= Number(amount),\n      });\n    })\n    .catch((e) => {\n      console.log(\"setIsContractAllowedToSpendToken\", e);\n    });\n};\n\nconst setNonce = (props) => {\n  console.log(\"setNonce\", props);\n  const { token } = props;\n  const signer = Ethers.provider().getSigner();\n\n  const abi = [\n    \"function nonces(address owner) external view returns (uint256)\",\n  ];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider()\n  );\n\n  erc20contract\n    .nonces(sender)\n    .then((nonce) => {\n      console.log(\"nonce\", nonce);\n      State.update({ nonce });\n    })\n    .catch((e) => {\n      console.log(\"setNonce err:\", e);\n    });\n};\n\nconst handlePermit = (props) => {\n  console.log(\"handlePermit\", props);\n  const { amount, token, network } = props;\n\n  const domain = {\n    chainId,\n    name: state.name,\n    verifyingContract: token.address,\n    version: \"1\",\n  };\n\n  const types = {\n    Permit: [\n      { name: \"owner\", type: \"address\" },\n      { name: \"spender\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"nonce\", type: \"uint256\" },\n      { name: \"deadline\", type: \"uint256\" },\n    ],\n  };\n\n  const values = {\n    deadline: MAX_AMOUNT,\n    nonce: state.nonce || 0,\n    owner: sender,\n    spender: BRIDGE_CONTRACT_ADDRESS,\n    value: ethers.BigNumber.from(amount),\n  };\n\n  console.log({ domain, types, values });\n\n  Ethers.provider()\n    .getSigner()\n    ._signTypedData(domain, types, values)\n    .then((signature) => {\n      console.log(\"signature\", signature);\n      const { r, s, v } = ethers.utils.splitSignature(signature);\n\n      console.log({ r, s, v });\n\n      const erc20Abi = [\n        {\n          inputs: [\n            {\n              internalType: \"address\",\n              name: \"owner\",\n              type: \"address\",\n            },\n            {\n              internalType: \"address\",\n              name: \"spender\",\n              type: \"address\",\n            },\n            {\n              internalType: \"uint256\",\n              name: \"value\",\n              type: \"uint256\",\n            },\n            {\n              internalType: \"uint256\",\n              name: \"deadline\",\n              type: \"uint256\",\n            },\n            {\n              internalType: \"uint8\",\n              name: \"v\",\n              type: \"uint8\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"r\",\n              type: \"bytes32\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"s\",\n              type: \"bytes32\",\n            },\n          ],\n          name: \"permit\",\n          outputs: [],\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ];\n\n      const erc20Iface = new ethers.utils.Interface(erc20Abi);\n\n      const permit = erc20Iface.encodeFunctionData(\n        \"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\",\n        [\n          sender,\n          BRIDGE_CONTRACT_ADDRESS,\n          ethers.BigNumber.from(amount),\n          MAX_AMOUNT,\n          v,\n          r,\n          s,\n        ]\n      );\n\n      console.log(\"permitData\", permit);\n      handleBridge({ ...props, permit });\n    });\n};\n\nconst approve = (props) => {\n  const { token, network, amount } = props;\n  if (isContractAllowedToSpendToken) return;\n\n  const abi = [\n    \"function approve(address spender, uint256 amount) external returns (bool)\",\n  ];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  return erc20contract.approve(\n    BRIDGE_CONTRACT_ADDRESS,\n    ethers.BigNumber.from(MAX_AMOUNT)\n  );\n};\n\nconst onConfirm = (props) => {\n  const { token, network, amount } = props;\n  if (token.symbol !== \"ETH\" && network === \"ethereum\") {\n    const res = approve(props);\n    console.log(\"approve response:\", res);\n    if (res) {\n      res\n        .then((tx) => {\n          console.log(\"approve\", tx);\n          handlePermit(props);\n        })\n        .catch((e) => {\n          console.log(\"approve err\", e);\n        });\n    } else {\n      handlePermit(props);\n    }\n  } else {\n    handleBridge(props);\n  }\n};\n\nconst onChangeAmount = (props) => {\n  console.log(\"onChangeAmount\", props);\n  setIsContractAllowedToSpendToken(props);\n};\n\nconst onUpdateToken = (props) => {\n  console.log(\"onUpdateToken\", props);\n  setIsContractAllowedToSpendToken(props);\n  setName(props.token);\n  setNonce(props);\n};\n\nif (!sender) {\n  return (\n    <Container>\n      <div className=\"w3button\">\n        <Web3Connect connectLabel=\"Connect to a wallet\" />\n      </div>\n    </Container>\n  );\n}\n\nreturn (\n  <Layout>\n    <div class=\"title\">\n      <h5>Bridge</h5>\n    </div>\n    <Container>\n      <Widget\n        src=\"ciocan.near/widget/zkevm-bridge-ui\"\n        props={{ onConfirm, onUpdateToken, onChangeAmount, tokens }}\n      />\n      <div class=\"side\">\n        <Widget\n          src=\"ciocan.near/widget/zkevm-bridge-transactions\"\n          props={{ tokens }}\n        />\n      </div>\n      <Widget\n        src=\"ciocan.near/widget/toast\"\n        props={{ open: isToastOpen, variant, title, description, onOpenChange }}\n      />\n    </Container>\n  </Layout>\n);\n"
    },
    "ciocan.near/widget/zkevm-bridge-transactions": {
      "code": "const Layout = styled.div`\n    position: relative;\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 12px;\n    line-height: 14px;\n    padding: 8px 16px;\n    background-color: #151718;\n    border-radius: 12px;\n    max-width: 240px;\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n    color: #fff;\n\n    h3 {\n        font-size: 14px;\n    }\n\n    .refresh {\n        border: none;\n        background: rgba(255, 255, 255, 0.6);\n    }\n\n    ul {\n        list-style: none;\n        margin-top: 16px;\n        padding: 0;\n        margin: 0;\n        display: flex;\n        flex-direction: column;\n        gap: 8px;\n\n        li {\n            background: #2d2f30;\n            padding: 4px 8px;\n            display: flex;\n            justify-content: space-between;\n            gap: 4px;\n\n            .info {\n                display: flex;\n                flex-direction: column;\n                gap: 4px;\n\n                .token {\n                    font-weight: bold;\n                }\n\n                a{ \n                    color: lightblue;\n                }\n\n                .date {\n                    font-size: 10px;\n                    color: rgba(255, 255, 255, 0.6);\n                }\n            }\n\n            button {\n                font-size: 12px;\n                color: #fff;\n                background: #8247E5;\n                border: none;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                justify-content: center;\n                width: 100px;\n            }\n        }\n    }\n`;\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"bytes32[32]\",\n        name: \"smtProof\",\n        type: \"bytes32[32]\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"index\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"mainnetExitRoot\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"rollupExitRoot\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"originNetwork\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"originTokenAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"destinationNetwork\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"address\",\n        name: \"destinationAddress\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"metadata\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"claimAsset\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n];\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst tokens = props.tokens ?? [];\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nState.init({\n  deposit: [],\n  withdraw: [],\n  isToastOpen: false,\n});\n\nconst onOpenChange = (v) => {\n  State.update({\n    isToastOpen: false,\n  });\n};\n\nconst { chainId, withdraw, deposit, isToastOpen, variant, title, description } =\n  state;\n\nconst isMainnet = chainId === 1 || chainId === 1101;\n\nconst BRIDGE_CONTRACT_ADDRESS = isMainnet\n  ? \"0x2a3DD3EB832aF982ec71669E178424b10Dca2EDe\"\n  : \"0xF6BEEeBB578e214CA9E23B0e9683454Ff88Ed2A7\";\n\nconst getTransactions = (type) => {\n  if (!sender) return;\n\n  asyncFetch(\n    `https://open-api-v2-staging.polygon.technology/zkevm-${\n      isMainnet ? \"mainnet\" : \"testnet\"\n    }/${type}/address?userAddress=${sender}`\n  ).then((res) => {\n    if (!res.body.success) {\n      return;\n    }\n    State.update({\n      [type]: res.body.result.filter((tx) => tx.status !== \"CLAIMED\"),\n    });\n  });\n};\n\nconst refreshList = () => {\n  getTransactions(\"withdraw\");\n  getTransactions(\"deposit\");\n};\n\nrefreshList();\n\nconst claimTransaction = (tx) => {\n  console.log(\"chainId\", chainId);\n  const isPolygonNetwork = chainId === 1101 || chainId === 1442;\n  if (isPolygonNetwork) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid network\",\n      description: \"Switch to ethereum network to claim transactions\",\n    });\n    return;\n  }\n\n  const url = `https://proof-generator.polygon.technology/api/zkevm/${\n    isMainnet ? \"mainnet\" : \"testnet\"\n  }/merkle-proof?net_id=1&deposit_cnt=${tx.counter}`;\n\n  asyncFetch(url).then((res) => {\n    if (!res.ok) {\n      console.log(\"merkele proof errror\", res);\n      return;\n    }\n\n    const { proof } = res.body;\n\n    const encodedData = bridgeIface.encodeFunctionData(\n      \"claimAsset(bytes32[32],uint32,bytes32,bytes32,uint32,address,uint32,address,uint256,bytes)\",\n      [\n        proof[\"merkle_proof\"],\n        tx.counter,\n        proof[\"main_exit_root\"],\n        proof[\"rollup_exit_root\"],\n        0,\n        tx.childToken,\n        0,\n        tx.depositReceiver,\n        tx.amounts[0],\n        \"0x\",\n      ]\n    );\n\n    Ethers.provider()\n      .getSigner()\n      .sendTransaction({\n        to: BRIDGE_CONTRACT_ADDRESS,\n        data: encodedData,\n        value: amountBig,\n        gasLimit: ethers.BigNumber.from(\"500000\"),\n      })\n      .then((tx) => {\n        consle.log(\"tx:\", tx);\n        refreshList();\n      })\n      .catch((e) => {\n        console.log(\"error:\", e);\n        refreshList();\n      });\n  });\n};\n\nconst noWithdrawls = withdraw?.length === 0;\nconst noDeposits = deposit?.length === 0;\nconst isEmpty = noWithdrawls && noDeposits;\n\nreturn (\n  <Layout>\n    <h3>Pending transactions:</h3>\n    <button class=\"refresh\" onClick={refreshList}>\n      refresh list\n    </button>\n    <ul>\n      {!noWithdrawls && <div>Withdrawls:</div>}\n      {withdraw.map((t) => {\n        const txUrl = `https://${\n          isMainnet ? \"\" : \"testnet-\"\n        }zkevm.polygonscan.com/tx/${t.transactionHash}`;\n\n        const token = tokens.find(\n          (token) => t.childToken.toLowerCase() === token.address.toLowerCase()\n        );\n\n        if (!token) return null;\n\n        const amount = ethers.utils.formatUnits(\n          t.amounts[0],\n          token?.decimals || 18\n        );\n\n        const isPending = t.status === \"BRIDGED\";\n\n        return (\n          <li>\n            <div class=\"info\">\n              <span class=\"token\">\n                {amount} {token?.symbol}\n              </span>\n              <a href={txUrl} target=\"_blank\">\n                Tx info\n              </a>\n              <span class=\"date\">{t.timestamp.slice(0, -8)}</span>\n            </div>\n            <button disabled={isPending} onClick={() => claimTransaction(t)}>\n              <span>Claim</span>\n              {isPending && <span>(pending... arrive in ~60 mins)</span>}\n            </button>\n          </li>\n        );\n      })}\n\n      {!noDeposits && <div>Deposits:</div>}\n\n      {deposit.map((t) => {\n        const txUrl = `https://${isMainnet ? \"\" : \"goerli.\"}etherscan.io/tx/${\n          t.transactionHash\n        }`;\n\n        const token = tokens.find(\n          (token) => t.rootToken.toLowerCase() === token.address.toLowerCase()\n        );\n\n        if (!token) return null;\n\n        const amount = ethers.utils.formatUnits(\n          t.amounts[0],\n          token?.decimals || 18\n        );\n\n        return (\n          <li>\n            <div class=\"info\">\n              <span class=\"token\">\n                {amount} {token?.symbol}\n              </span>\n              <a href={txUrl} target=\"_blank\">\n                Tx info\n              </a>\n              <span class=\"date\">{t.timestamp.slice(0, -8)}</span>\n              <span>Funds will arrive in ~15 mins</span>\n            </div>\n          </li>\n        );\n      })}\n      {isEmpty && (\n        <li>\n          <span>0 pending transactions</span>\n        </li>\n      )}\n    </ul>\n    <Widget\n      src=\"ciocan.near/widget/toast\"\n      props={{ open: isToastOpen, variant, title, description, onOpenChange }}\n    />\n  </Layout>\n);\n"
    },
    "ciocan.near/widget/toast": {
      "code": "const Wrapper = styled.div`\n/* reset */\nbutton {\n  all: unset;\n}\n\n.ToastViewport {\n  --viewport-padding: 25px;\n  position: fixed;\n  bottom: 0;\n  right: 0;\n  display: flex;\n  flex-direction: column;\n  padding: var(--viewport-padding);\n  gap: 10px;\n  width: 390px;\n  max-width: 100vw;\n  margin: 0;\n  list-style: none;\n  z-index: 2147483647;\n  outline: none;\n}\n\n.ToastRoot {\n  background-color: white;\n  border-radius: 6px;\n  box-shadow: hsl(206 22% 7% / 35%) 0px 10px 38px -10px, hsl(206 22% 7% / 20%) 0px 10px 20px -15px;\n  padding: 15px;\n  display: grid;\n  grid-template-areas: 'title action' 'description action';\n  grid-template-columns: auto max-content;\n  column-gap: 15px;\n  align-items: center;\n}\n.ToastRoot[data-state='open'] {\n  animation: slideIn 150ms cubic-bezier(0.16, 1, 0.3, 1);\n}\n.ToastRoot[data-state='closed'] {\n  animation: hide 100ms ease-in;\n}\n.ToastRoot[data-swipe='move'] {\n  transform: translateX(var(--radix-toast-swipe-move-x));\n}\n.ToastRoot[data-swipe='cancel'] {\n  transform: translateX(0);\n  transition: transform 200ms ease-out;\n}\n.ToastRoot[data-swipe='end'] {\n  animation: swipeOut 100ms ease-out;\n}\n\n@keyframes hide {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n@keyframes slideIn {\n  from {\n    transform: translateX(calc(100% + var(--viewport-padding)));\n  }\n  to {\n    transform: translateX(0);\n  }\n}\n\n@keyframes swipeOut {\n  from {\n    transform: translateX(var(--radix-toast-swipe-end-x));\n  }\n  to {\n    transform: translateX(calc(100% + var(--viewport-padding)));\n  }\n}\n\n.ToastTitle {\n  grid-area: title;\n  margin-bottom: 5px;\n  font-weight: 500;\n  color: rgb(27, 27, 24) !important;\n  font-size: 15px !important;\n}\n\n.ToastDescription {\n  grid-area: description;\n  margin: 0;\n  color: rgb(27, 27, 24) !important;\n  font-size: 13px !important;\n  line-height: 1.3 !important;\n  font-style: normal;\n}\n\n.ToastAction {\n  grid-area: action;\n}\n\n.error {\n  background: pink;\n}\n\n.success {\n  background: lightblue;\n}\n`;\n\nconst { variant, open, onOpenChange, title, description } = props;\n\nreturn (\n  <Wrapper>\n    <Toast.Provider swipeDirection=\"right\">\n      <Toast.Root\n        className={`ToastRoot ${variant}`}\n        open={open}\n        onOpenChange={onOpenChange}\n      >\n        <Toast.Title className=\"ToastTitle\">{title}</Toast.Title>\n        <Toast.Description className=\"ToastDescription\">\n          {description}\n        </Toast.Description>\n        <Toast.Action className=\"ToastAction\" asChild altText=\"Close\">\n          <button className=\"\">x</button>\n        </Toast.Action>\n      </Toast.Root>\n      <Toast.Viewport className=\"ToastViewport\" />\n    </Toast.Provider>\n  </Wrapper>\n);\n"
    },
    "ciocan.near/widget/zkevm": {
      "code": "const logo = (\n  <svg width=\"260\" height=\"40\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <g clip-path=\"url(#a)\">\n      <path\n        d=\"M48.928 37.816V16.524h3.18l.279 1.726h.167c.89-1.17 2.45-2.005 4.573-2.005 3.904 0 7.079 3.181 7.079 7.915 0 4.733-3.125 7.914-7.086 7.914-2.116 0-3.57-.89-4.35-1.893h-.167v7.58h-3.682v.055h.007ZM60.524 24.16c0-2.785-1.782-4.517-3.96-4.517-2.179 0-3.96 1.726-3.96 4.517 0 2.79 1.781 4.517 3.96 4.517 2.178 0 3.96-1.726 3.96-4.517ZM66.043 24.16c0-4.629 3.348-7.915 7.748-7.915 4.461 0 7.747 3.348 7.747 7.915 0 4.628-3.348 7.914-7.747 7.914-4.462 0-7.748-3.341-7.748-7.914Zm11.813 0c0-2.73-1.782-4.517-4.072-4.517-2.227 0-4.071 1.782-4.071 4.517 0 2.735 1.838 4.517 4.072 4.517 2.233 0 4.071-1.782 4.071-4.517ZM84.21 31.796V10.67h3.683v21.126H84.21ZM101.605 16.524h3.905l-6.634 18.564c-.668 1.837-1.559 2.728-3.96 2.728h-3.564v-3.403h3.007c.557 0 .836-.278 1.003-.724l.334-1.002-6.244-16.17h3.905l3.96 10.594h.613l3.57-10.593h.105v.006ZM106.233 32.581h3.738c.167 1.003 1.169 2.34 3.515 2.34 2.227 0 3.681-1.393 3.681-3.515V29.29H117c-.835.89-2.339 1.67-4.238 1.67-3.905 0-6.968-3.007-6.968-7.357s3.007-7.358 6.968-7.358c2.004 0 3.514.836 4.461 1.95h.167l.279-1.671h3.18v14.882c0 4.072-2.729 6.745-7.357 6.745-5.198 0-7.147-3.398-7.259-5.57Zm10.872-8.978c0-2.395-1.67-4.072-3.848-4.072-2.117 0-3.794 1.67-3.794 4.072 0 2.4 1.671 4.071 3.794 4.071 2.122 0 3.848-1.676 3.848-4.071ZM123.35 24.16c0-4.629 3.347-7.915 7.747-7.915 4.461 0 7.747 3.348 7.747 7.915 0 4.628-3.347 7.914-7.747 7.914-4.462 0-7.747-3.341-7.747-7.914Zm11.819 0c0-2.73-1.838-4.517-4.072-4.517-2.228 0-4.072 1.782-4.072 4.517 0 2.735 1.838 4.517 4.072 4.517 2.228 0 4.072-1.782 4.072-4.517ZM141.412 31.796V16.524h3.181l.278 1.448h.167c.613-.668 2.117-1.727 4.406-1.727 3.515 0 6.021 2.506 6.021 6.411v9.195h-3.682v-8.694c0-1.949-1.392-3.403-3.292-3.403a3.377 3.377 0 0 0-3.403 3.403v8.694h-3.676v-.055Z\"\n        fill=\"#fff\"\n      />\n      <path\n        d=\"m29.082 30.014 9.029-5.241a1.5 1.5 0 0 0 .78-1.337V12.954a1.5 1.5 0 0 0-.78-1.337l-9.029-5.241a1.56 1.56 0 0 0-1.559 0l-9.034 5.24a1.5 1.5 0 0 0-.78 1.338v18.675l-6.355 3.681-6.355-3.681v-7.302l6.355-3.682 4.183 2.395v-4.907l-3.403-1.95c-.223-.11-.502-.222-.78-.222s-.557.056-.78.223L1.54 21.43a1.5 1.5 0 0 0-.78 1.337V33.25a1.5 1.5 0 0 0 .78 1.337l9.028 5.24a1.56 1.56 0 0 0 1.56 0l9.028-5.24a1.5 1.5 0 0 0 .78-1.337V14.575l.11-.056 6.25-3.626 6.355 3.682v7.302l-6.355 3.675-4.183-2.395v4.907l3.404 1.95a1.571 1.571 0 0 0 1.565 0Z\"\n        fill=\"url(#b)\"\n      />\n    </g>\n    <path\n      d=\"M165.162 30.607v-1.554l9.787-13.38v-.144h-9.368v-1.851h11.892v1.62l-9.611 13.314v.143h9.964v1.852h-12.664Zm18.034-6.393-.022-2.568h.44l7.936-7.968h2.48l-7.837 7.847-.176.033-2.821 2.656Zm-1.786 6.393V8.035h1.962v22.572h-1.962Zm10.548 0-6.878-8.696 1.411-1.356 7.98 10.052h-2.513Zm5.427 0V8.035h13.094v1.851h-11.033v8.498h10.339v1.852h-10.339v8.52h11.253v1.85h-13.314Zm17.723-22.572 7.053 19.894h.199l7.054-19.894h2.16l-8.211 22.572h-2.205l-8.211-22.572h2.161Zm19.595 0h2.381l8.189 19.662h.198l8.189-19.662h2.381v22.572h-1.94V12.388h-.176l-7.616 18.219h-1.874l-7.616-18.219h-.176v18.219h-1.94V8.035Z\"\n      fill=\"#fff\"\n    />\n    <defs>\n      <linearGradient\n        id=\"b\"\n        x1=\".698\"\n        y1=\"34.279\"\n        x2=\"37.045\"\n        y2=\"13.04\"\n        gradientUnits=\"userSpaceOnUse\"\n      >\n        <stop stop-color=\"#A726C1\" />\n        <stop offset=\".878\" stop-color=\"#803BDF\" />\n        <stop offset=\"1\" stop-color=\"#7B3FE4\" />\n      </linearGradient>\n      <clipPath id=\"a\">\n        <path fill=\"#fff\" d=\"M.76 6.209h154.698v33.786H.76z\" />\n      </clipPath>\n    </defs>\n  </svg>\n);\n\nconst Container = styled.div`\n    padding: 0;\n    margin:0;\n    width: 100%;\n    min-width: 1000px;\n    height: 100%;\n    min-height: 400px;\n    display: grid;\n    place-items: center;\n    padding-top: 100px;\n    padding-bottom: 100px;\n    margin: 0 auto;\n    background: url(https://bafybeifnxzoabfcn4txprj7pkexb4adkcxnp34qfnsk3wkztay2sweuh44.ipfs.w3s.link/polygon-bg-optimized.png) no-repeat center center; \n    -webkit-background-size: cover;\n    -moz-background-size: cover;\n    -o-background-size: cover;\n    background-size: cover;\n    background-color: #0D0E20;\n\n    .center {\n      display: grid;\n      align-items: center;\n      justify-items: center;\n    }\n\n    .logo {\n        margin: 1rem;\n    }\n\n    .radio {\n        display: inline-flex;\n        justify-content: center;\n        border-radius: 999px;\n        background-color: #353535;\n\n        .item {\n          border: none;\n          font-family: 'Inter';\n          font-style: normal;\n          font-weight: 600;\n          font-size: 12px;\n          line-height: 15px;\n          padding: 6px 8px;\n          border-radius: 999px;\n          background-color: #353535;\n          color: white;\n        }\n\n        .item[data-state='checked'] {\n          background-color: #8247E5;\n          border-radius: 999px;\n        }\n    }\n\n    .component {\n      margin-top: 1.5rem;\n    }\n`;\n\nState.init({ radio: \"bridge\" });\n\nconst handleRadioChange = (radio) => {\n  State.update({ radio });\n};\n\nconst { radio } = state;\n\nreturn (\n  <Container>\n    <div className=\"center\">\n      <div className=\"logo\">{logo}</div>\n      <RadioGroup.Root\n        className=\"radio\"\n        type=\"single\"\n        defaultValue=\"bridge\"\n        aria-label=\"zkevm\"\n        onValueChange={handleRadioChange}\n      >\n        <RadioGroup.Item className=\"item\" value=\"bridge\" aria-label=\"Bridge\">\n          <span>Bridge</span>\n        </RadioGroup.Item>\n        <RadioGroup.Item className=\"item\" value=\"swap\" aria-label=\"Swap\">\n          <span>Swap</span>\n        </RadioGroup.Item>\n      </RadioGroup.Root>\n      <div className=\"component\">\n        {radio === \"bridge\" ? (\n          <Widget src=\"ciocan.near/widget/zkevm-bridge\" />\n        ) : (\n          <Widget src=\"zavodil.near/widget/swap-styled\" />\n        )}\n      </div>\n    </div>\n  </Container>\n);\n"
    },
    "ciocan.near/widget/hello-world": {
      "code": "return <div>Hello World</div>;\n"
    },
    "ciocan.near/widget/op-bridge-demo": {
      "code": "// for goerli\nconst OP_BRIDGE_DEPOSIT_CONTRACT = \"0x636Af16bf2f682dD3109e60102b8E1A089FedAa8\";\nconst OP_BRIDGE_WITHDRAW_CONTRACT =\n  \"0x4200000000000000000000000000000000000010\";\nconst ETH_ADDR = \"0x0000000000000000000000000000000000000000\";\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (!sender) {\n  return (\n    <div className=\"w3button\">\n      <Web3Connect connectLabel=\"Connect to a wallet\" />\n    </div>\n  );\n}\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isTestnet = chainId === 5 || chainId === 420;\nconst isCorrectNetwork = isMainnet || isTestnet;\n\nconsole.log(\"isCorrectNetwork\", isCorrectNetwork);\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"_l2Gas\", type: \"uint32\" },\n      { internalType: \"bytes\", name: \"_data\", type: \"bytes\" },\n    ],\n    name: \"depositETH\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n];\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nfunction getDeposits() {\n  console.log(\"getDeposits\");\n  const bridgeContract = new ethers.Contract(\n    OP_BRIDGE_DEPOSIT_CONTRACT,\n    bridgeAbi,\n    Ethers.provider().getSigner()\n  );\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ETHDepositInitiated(sender))\n    .then((events) => {\n      console.log(events);\n      events.forEach((ev) => {\n        ev.getTransaction().then((tx) => console.log(\"tx\", tx));\n        ev.getTransactionReceipt().then((tx) => console.log(\"txr\", tx));\n      });\n    });\n}\n\ngetDeposits();\n\nfunction handleDepositETH() {\n  console.log(\"deposit\", isTestnet);\n  if (!isCorrectNetwork) return;\n  if (!isTestnet) return;\n\n  const amountBig = ethers.utils.parseUnits(\"0.05\", 18);\n\n  const encodedData = bridgeIface.encodeFunctionData(\n    \"depositETH(uint32, bytes)\",\n    [200000, 0]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: OP_BRIDGE_DEPOSIT_CONTRACT,\n      data: encodedData,\n      value: amountBig,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n    });\n}\n\nfunction handleWithdraw() {\n  console.log(\"withdraw\");\n  if (!isCorrectNetwork) return;\n  if (!isTestnet) return;\n}\n\nif (!sender) {\n  return (\n    <div className=\"w3button\">\n      <Web3Connect connectLabel=\"Connect to a wallet\" />\n    </div>\n  );\n}\n\nreturn (\n  <div>\n    <button onClick={handleDepositETH}>Deposit 0.05 ETH to L2</button>\n    <button onClick={handleWithdraw}>Withdraw 0.05 ETH</button>\n  </div>\n);\n"
    },
    "ciocan.near/widget/op-bridge-list": {
      "code": "const tokens = [\n  // eth testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x07865c6E87B9F70255377e024ace6630C1Eaa37F\",\n    chainId: 5,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  // eth mainnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n    chainId: 1,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n];\n\nconst Container = styled.div`\n    --op-primary-600: #EB0822;\n\n    td, th {\n        padding: 2px 5px;\n        font-size: 12px;\n    }\n    button,\n    fieldset,\n    input {\n        all: unset;\n    }\n\n    .TabsRoot {\n        display: flex;\n        flex-direction: column;\n        max-width: 640px;\n    }\n\n    .TabsList {\n        flex-shrink: 0;\n        display: flex;\n        border-bottom: 1px solid var(--mauve-6);\n    }\n\n    .TabsTrigger {\n        font-family: inherit;\n        background-color: white;\n        padding: 0 20px;\n        height: 45px;\n        flex: 1;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font-size: 15px;\n        line-height: 1;\n        user-select: none;\n    }\n    .TabsTrigger:first-child {\n        border-top-left-radius: 6px;\n    }\n    .TabsTrigger:last-child {\n        border-top-right-radius: 6px;\n    }\n    .TabsTrigger[data-state='active'] {\n        box-shadow: inset 0 -1px 0 0 var(--op-primary-600), 0 1px 0 0 var(--op-primary-600);\n    }\n\n    .TabsContent {\n        flex-grow: 1;\n        padding: 20px;\n        background-color: white;\n        border-bottom-left-radius: 6px;\n        border-bottom-right-radius: 6px;\n        outline: none;\n    }\n`;\n\nreturn (\n  <Container>\n    <Tabs.Root className=\"TabsRoot\" defaultValue=\"deposits\">\n      <Tabs.List className=\"TabsList\" aria-label=\"Transactions List\">\n        <Tabs.Trigger className=\"TabsTrigger\" value=\"deposits\">\n          Deposits\n        </Tabs.Trigger>\n        <Tabs.Trigger className=\"TabsTrigger\" value=\"withdrawals\">\n          Withdrawals\n        </Tabs.Trigger>\n      </Tabs.List>\n      <Tabs.Content className=\"TabsContent\" value=\"deposits\">\n        <Widget\n          src=\"ciocan.near/widget/op-bridge-list-deposits\"\n          props={{ tokens }}\n        />\n      </Tabs.Content>\n      <Tabs.Content className=\"TabsContent\" value=\"withdrawals\">\n        <Widget\n          src=\"ciocan.near/widget/op-bridge-list-withdrawals\"\n          props={{ tokens }}\n        />\n      </Tabs.Content>\n    </Tabs.Root>\n  </Container>\n);\n"
    },
    "ciocan.near/widget/op-bridge-list-deposits": {
      "code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst tokens = props.tokens ?? [];\n\nState.init({\n  ethdeposits: [],\n  ercdeposits: [],\n});\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isTestnet = chainId === 5 || chainId === 420;\nconst isCorrectNetwork = isMainnet || isTestnet;\n\nif (![1, 5].includes(chainId)) {\n  return <h6>Switch to Ethereum network to see the deposits list.</h6>;\n}\n\nconst OP_BRIDGE_DEPOSIT_CONTRACT = isTestnet\n  ? \"0x636Af16bf2f682dD3109e60102b8E1A089FedAa8\"\n  : \"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1\";\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_l1Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"_l2Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"_minGasLimit\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"depositERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20DepositInitiated\",\n    type: \"event\",\n  },\n];\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\nconst bridgeContract = new ethers.Contract(\n  OP_BRIDGE_DEPOSIT_CONTRACT,\n  bridgeAbi,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHDeposits() {\n  // console.log(\"getETHDeposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ethdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ETHDepositInitiated(sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber, symbol: \"ETH\" });\n\n        ev.getTransaction().then((tx) => {\n          const { value, hash } = tx;\n          // console.log(\"tx\", tx);\n          const amount = ethers.utils.formatUnits(value, 18);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\nfunction getERC20Deposits() {\n  console.log(\"getERC20Deposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ercdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ERC20DepositInitiated(_, _, sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber });\n\n        ev.getTransaction().then((tx) => {\n          // console.log(\"tx\", tx);\n          const { hash, data } = tx;\n          const decodedData = bridgeIface.parseTransaction({ data });\n          const [l1Token, l2Token, value] = decodedData.args;\n          const token = tokens.find((t) => t.address === l1Token);\n          const amount = ethers.utils.formatUnits(value, token?.decimals || 6);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n            symbol: token?.symbol || \"???\",\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\ngetETHDeposits();\ngetERC20Deposits();\n\nfunction renderDeposit(deposit) {\n  //   console.log(\"deposit\", deposit);\n  const { timestamp, amount, transactionHash, symbol } = deposit;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli.\" : \"\"\n  }etherscan.io/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n  return (\n    <tr>\n      <td>{date.toUTCString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n    </tr>\n  );\n}\n\nconst { ethdeposits, ercdeposits } = state;\nconst deposits = [...ethdeposits, ...ercdeposits].sort(\n  (a, b) => b.timestamp - a.timestamp\n);\n\nreturn (\n  <table>\n    <thead>\n      <tr>\n        <th>Time</th>\n        <th>Amount</th>\n        <th>Token</th>\n        <th>Transaction</th>\n      </tr>\n    </thead>\n    <tbody>{deposits.map(renderDeposit)}</tbody>\n  </table>\n);\n"
    },
    "ciocan.near/widget/op-bridge-list-withdrawals": {
      "code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst tokens = props.tokens ?? [];\n\nState.init({\n  withdrawals: [],\n});\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isTestnet = chainId === 5 || chainId === 420;\nconst isCorrectNetwork = isMainnet || isTestnet;\n\nif (![10, 420].includes(chainId)) {\n  return <h6>Switch to Optimism network to see the deposits list.</h6>;\n}\n\nconst OP_BRIDGE_DEPOSIT_CONTRACT = isTestnet\n  ? \"0x636Af16bf2f682dD3109e60102b8E1A089FedAa8\"\n  : \"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1\";\n\nconst OP_BRIDGE_WITHDRAW_CONTRACT = isTestnet\n  ? \"0x4200000000000000000000000000000000000010\"\n  : \"0x4200000000000000000000000000000000000010\";\n\nconst bridgeAbiDeposit = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20WithdrawalFinalized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHWithdrawalFinalized\",\n    type: \"event\",\n  },\n];\n\nconst bridgeAbiWithdrawal = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"WithdrawalInitiated\",\n    type: \"event\",\n  },\n];\n\nconst bridgeIfaceDeposit = new ethers.utils.Interface(bridgeAbiDeposit);\nconst bridgeContractDeposit = new ethers.Contract(\n  OP_BRIDGE_DEPOSIT_CONTRACT,\n  bridgeAbiDeposit,\n  Ethers.provider().getSigner()\n);\n\nconst bridgeContractWithdrawal = new ethers.Contract(\n  OP_BRIDGE_WITHDRAW_CONTRACT,\n  bridgeAbiWithdrawal,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHWithdrawals() {\n  // console.log(\"getETHWithdrawals\");\n  const withdrawals = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      // console.log(\"done\");\n      State.update({\n        withdrawals,\n      });\n    }\n  }\n\n  // bridgeContractDeposit\n  //   .queryFilter(bridgeContractDeposit.filters.ETHWithdrawalFinalized(sender))\n  //   .then((events) => {\n  //     console.log(\"finalized\", events);\n  //   });\n\n  bridgeContractWithdrawal\n    .queryFilter(\n      bridgeContractWithdrawal.filters.WithdrawalInitiated(\n        undefined,\n        undefined,\n        sender\n      )\n    )\n    .then((events) => {\n      console.log(\"WithdrawalInitiated\", events);\n      totalOperations = events.length * 1; // async operations for each event\n\n      events\n        .sort((a, b) => b.blockNumber - a.blockNumber)\n        .forEach((event) => {\n          const { args, logIndex, blockNumber, transactionHash } = event;\n          const [l1token, l2token, from, to, amount, extraData] = args;\n          // console.log(transactionHash, event);\n          const token = tokens.find((t) => t.address === l1token);\n\n          withdrawals.set(transactionHash, {\n            l1token,\n            l2token,\n            // from,\n            // to,\n            symbol: token?.symbol ?? \"????\",\n            amount: ethers.utils.formatUnits(amount, token?.decimals || 18),\n            extraData,\n            logIndex,\n            blockNumber,\n            transactionHash,\n          });\n\n          event.getBlock().then((block) => {\n            // console.log(transactionHash, \"block\", block);\n            const { timestamp } = block;\n            withdrawals.set(transactionHash, {\n              ...withdrawals.get(transactionHash),\n              timestamp,\n            });\n            completedOperations++;\n            checkAllOperationsComplete();\n          });\n\n          event.getTransactionReceipt().then((receipt) => {\n            console.log(\"receipt\", receipt);\n            const abi = [\n              \"event Transfer (address indexed from, address indexed to, uint256 value)\",\n              \"event Burn (address indexed _account, uint256 _amount)\",\n              \"event SentMessage (address indexed target, address sender, bytes message, uint256 messageNonce, uint256 gasLimit)\",\n              \"event WithdrawalInitiated (address indexed _l1Token, address indexed _l2Token, address indexed _from, address _to, uint256 _amount, bytes _data)\",\n            ];\n            const iface = new ethers.utils.Interface(abi);\n            Ethers.provider()\n              .getTransactionReceipt(receipt.transactionHash)\n              .then((l2Rcpt) => {\n                const logEvents = l2Rcpt.logs\n                  .map((x) => {\n                    try {\n                      const res = iface.parseLog(x);\n                      res.address = x.address;\n                      return res;\n                    } catch (e) {}\n                  })\n                  .filter((e) => e != undefined);\n                console.log(\"logEvents\", logEvents);\n              });\n          });\n        });\n    });\n}\n\ngetETHWithdrawals();\n\nfunction renderWithdrawal([_, withdrawal]) {\n  // console.log(\"withdraw\", withdrawal);\n  const { timestamp, amount, transactionHash, symbol } = withdrawal;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli-optimism.etherscan.io\" : \"optimistic.etherscan.io\"\n  }/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n  return (\n    <tr>\n      <td>{date.toUTCString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n      <td>status</td>\n      <td>\n        <button>action</button>\n      </td>\n    </tr>\n  );\n}\n\nreturn (\n  <table>\n    <thead>\n      <tr>\n        <th>Time</th>\n        <th>Amount</th>\n        <th>Token</th>\n        <th>Transaction</th>\n        <th>Status</th>\n        <th></th>\n      </tr>\n    </thead>\n    <tbody>{[...state.withdrawals].map(renderWithdrawal)}</tbody>\n  </table>\n);\n"
    },
    "ciocan.near/widget/optimism-bridge-transactions-list": {
      "code": "const tokens = [\n  // eth testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x07865c6E87B9F70255377e024ace6630C1Eaa37F\",\n    chainId: 5,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  // eth mainnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n    chainId: 1,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n];\n\nconst Container = styled.div`\n    --op-primary-600: #EB0822;\n\n    td, th {\n        padding: 2px 5px;\n        font-size: 12px;\n    }\n    button,\n    fieldset,\n    input {\n        all: unset;\n    }\n\n    .TabsRoot {\n        display: flex;\n        flex-direction: column;\n        max-width: 640px;\n    }\n\n    .TabsList {\n        flex-shrink: 0;\n        display: flex;\n        border-bottom: 1px solid var(--mauve-6);\n    }\n\n    .TabsTrigger {\n        font-family: inherit;\n        background-color: white;\n        padding: 0 20px;\n        height: 45px;\n        flex: 1;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font-size: 15px;\n        line-height: 1;\n        user-select: none;\n    }\n    .TabsTrigger:first-child {\n        border-top-left-radius: 6px;\n    }\n    .TabsTrigger:last-child {\n        border-top-right-radius: 6px;\n    }\n    .TabsTrigger[data-state='active'] {\n        box-shadow: inset 0 -1px 0 0 var(--op-primary-600), 0 1px 0 0 var(--op-primary-600);\n    }\n\n    .TabsContent {\n        flex-grow: 1;\n        padding: 20px;\n        background-color: white;\n        border-bottom-left-radius: 6px;\n        border-bottom-right-radius: 6px;\n        outline: none;\n    }\n`;\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nState.init({\n  ethdeposits: [],\n  ercdeposits: [],\n  withdrawals: [],\n});\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 10;\nconst isTestnet = chainId === 5 || chainId === 420;\nconst isCorrectNetwork = isMainnet || isTestnet;\nconst isEthNetwork = [1, 5].includes(chainId);\nconst isOpNetwork = [10, 420].includes(chainId);\n\nconst OP_BRIDGE_DEPOSIT_CONTRACT = isTestnet\n  ? \"0x636Af16bf2f682dD3109e60102b8E1A089FedAa8\"\n  : \"0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1\";\n\nconst OP_BRIDGE_WITHDRAW_CONTRACT = isTestnet\n  ? \"0x4200000000000000000000000000000000000010\"\n  : \"0x4200000000000000000000000000000000000010\";\n\nconst bridgeAbiDeposit = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_l1Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"_l2Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"_minGasLimit\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"depositERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20DepositInitiated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20WithdrawalFinalized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHWithdrawalFinalized\",\n    type: \"event\",\n  },\n];\n\nconst bridgeAbiWithdrawal = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"WithdrawalInitiated\",\n    type: \"event\",\n  },\n];\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbiDeposit);\nconst bridgeContract = new ethers.Contract(\n  OP_BRIDGE_DEPOSIT_CONTRACT,\n  bridgeAbiDeposit,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHDeposits() {\n  // console.log(\"getETHDeposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ethdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ETHDepositInitiated(sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber, symbol: \"ETH\" });\n\n        ev.getTransaction().then((tx) => {\n          const { value, hash } = tx;\n          // console.log(\"tx\", tx);\n          const amount = ethers.utils.formatUnits(value, 18);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\nfunction getERC20Deposits() {\n  console.log(\"getERC20Deposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ercdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ERC20DepositInitiated(_, _, sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber });\n\n        ev.getTransaction().then((tx) => {\n          // console.log(\"tx\", tx);\n          const { hash, data } = tx;\n          const decodedData = bridgeIface.parseTransaction({ data });\n          const [l1Token, l2Token, value] = decodedData.args;\n          const token = tokens.find((t) => t.address === l1Token);\n          const amount = ethers.utils.formatUnits(value, token?.decimals || 6);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n            symbol: token?.symbol || \"???\",\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\ngetETHDeposits();\ngetERC20Deposits();\n\nfunction renderDeposit(deposit) {\n  //   console.log(\"deposit\", deposit);\n  const { timestamp, amount, transactionHash, symbol } = deposit;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli.\" : \"\"\n  }etherscan.io/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n  return (\n    <tr>\n      <td>{date.toUTCString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n    </tr>\n  );\n}\n\nconst { ethdeposits, ercdeposits } = state;\nconst deposits = [...ethdeposits, ...ercdeposits].sort(\n  (a, b) => b.timestamp - a.timestamp\n);\n\nconst bridgeContractWithdrawal = new ethers.Contract(\n  OP_BRIDGE_WITHDRAW_CONTRACT,\n  bridgeAbiWithdrawal,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHWithdrawals() {\n  // console.log(\"getETHWithdrawals\");\n  const withdrawals = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      // console.log(\"done\");\n      State.update({\n        withdrawals,\n      });\n    }\n  }\n\n  bridgeContractWithdrawal\n    .queryFilter(\n      bridgeContractWithdrawal.filters.WithdrawalInitiated(\n        undefined,\n        undefined,\n        sender\n      )\n    )\n    .then((events) => {\n      console.log(\"WithdrawalInitiated\", events);\n      totalOperations = events.length * 1; // Three async operations for each event\n\n      events\n        .sort((a, b) => b.blockNumber - a.blockNumber)\n        .forEach((event) => {\n          const { args, logIndex, blockNumber, transactionHash } = event;\n          const [l1token, l2token, from, to, amount, extraData] = args;\n          // console.log(transactionHash, event);\n          const token = tokens.find((t) => t.address === l1token);\n\n          withdrawals.set(transactionHash, {\n            l1token,\n            l2token,\n            // from,\n            // to,\n            symbol: token?.symbol ?? \"????\",\n            amount: ethers.utils.formatUnits(amount, token?.decimals || 18),\n            extraData,\n            logIndex,\n            blockNumber,\n            transactionHash,\n          });\n\n          event.getBlock().then((block) => {\n            // console.log(transactionHash, \"block\", block);\n            const { timestamp } = block;\n            withdrawals.set(transactionHash, {\n              ...withdrawals.get(transactionHash),\n              timestamp,\n            });\n            completedOperations++;\n            checkAllOperationsComplete();\n          });\n        });\n    });\n}\n\ngetETHWithdrawals();\n\nfunction renderWithdrawal([_, withdrawal]) {\n  // console.log(\"withdraw\", withdrawal);\n  const { timestamp, amount, transactionHash, symbol } = withdrawal;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli-optimism.etherscan.io\" : \"optimistic.etherscan.io\"\n  }/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n  return (\n    <tr>\n      <td>{date.toUTCString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n      <td>status</td>\n      <td>\n        <button>action</button>\n      </td>\n    </tr>\n  );\n}\n\nreturn (\n  <Container>\n    <Tabs.Root className=\"TabsRoot\" defaultValue=\"deposits\">\n      <Tabs.List className=\"TabsList\" aria-label=\"Transactions List\">\n        <Tabs.Trigger className=\"TabsTrigger\" value=\"deposits\">\n          Deposits\n        </Tabs.Trigger>\n        <Tabs.Trigger className=\"TabsTrigger\" value=\"withdrawals\">\n          Withdrawals\n        </Tabs.Trigger>\n      </Tabs.List>\n      <Tabs.Content className=\"TabsContent\" value=\"deposits\">\n        {!isEthNetwork ? (\n          <h6>Switch to Ethereum network to see the deposits list.</h6>\n        ) : (\n          <>\n            <table>\n              <thead>\n                <tr>\n                  <th>Time</th>\n                  <th>Amount</th>\n                  <th>Token</th>\n                  <th>Transaction</th>\n                </tr>\n              </thead>\n              <tbody>{deposits.map(renderDeposit)}</tbody>\n            </table>\n          </>\n        )}\n      </Tabs.Content>\n      <Tabs.Content className=\"TabsContent\" value=\"withdrawals\">\n        {!isOpNetwork ? (\n          <h6>Switch to Optimism network to see the withdrawal list.</h6>\n        ) : (\n          <>\n            <table>\n              <thead>\n                <tr>\n                  <th>Time</th>\n                  <th>Amount</th>\n                  <th>Token</th>\n                  <th>Transaction</th>\n                  <th>Status</th>\n                  <th></th>\n                </tr>\n              </thead>\n              <tbody>{[...state.withdrawals].map(renderWithdrawal)}</tbody>\n            </table>\n          </>\n        )}\n      </Tabs.Content>\n    </Tabs.Root>\n  </Container>\n);\n"
    },
    "ciocan.near/widget/hello": {
      "code": "return <div>Hello World</div>;\n"
    },
    "ciocan.near/widget/base-bridge-transactions-list": {
      "code": "const tokens = [\n  // eth testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x07865c6E87B9F70255377e024ace6630C1Eaa37F\",\n    chainId: 5,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  // eth mainnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n    chainId: 1,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n];\n\nconst Container = styled.div`\n    --op-primary-600: #EB0822;\n\n    td, th {\n        padding: 2px 5px;\n        font-size: 12px;\n    }\n    button,\n    fieldset,\n    input {\n        all: unset;\n    }\n\n    .TabsRoot {\n        display: flex;\n        flex-direction: column;\n        max-width: 640px;\n    }\n\n    .TabsList {\n        flex-shrink: 0;\n        display: flex;\n        border-bottom: 1px solid var(--mauve-6);\n    }\n\n    .TabsTrigger {\n        font-family: inherit;\n        background-color: white;\n        padding: 0 20px;\n        height: 45px;\n        flex: 1;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        font-size: 15px;\n        line-height: 1;\n        user-select: none;\n    }\n    .TabsTrigger:first-child {\n        border-top-left-radius: 6px;\n    }\n    .TabsTrigger:last-child {\n        border-top-right-radius: 6px;\n    }\n    .TabsTrigger[data-state='active'] {\n        box-shadow: inset 0 -1px 0 0 var(--op-primary-600), 0 1px 0 0 var(--op-primary-600);\n    }\n\n    .TabsContent {\n        flex-grow: 1;\n        padding: 20px;\n        background-color: white;\n        border-bottom-left-radius: 6px;\n        border-bottom-right-radius: 6px;\n        outline: none;\n    }\n`;\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nState.init({\n  ethdeposits: [],\n  ercdeposits: [],\n  withdrawals: [],\n});\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst isMainnet = chainId === 1 || chainId === 8453;\nconst isTestnet = chainId === 5 || chainId === 84531;\nconst isCorrectNetwork = isMainnet || isTestnet;\nconst isEthNetwork = [1, 5].includes(chainId);\nconst isBaseNetwork = [8453, 84531].includes(chainId);\n\nconst BASE_BRIDGE_DEPOSIT_CONTRACT = isTestnet\n  ? //\n    \"0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a\"\n  : // \"0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA\"\n    \"0x3154Cf16ccdb4C6d922629664174b904d80F2C35\";\n\nconst BASE_BRIDGE_WITHDRAW_CONTRACT = isTestnet\n  ? \"0x4200000000000000000000000000000000000010\"\n  : \"0x4200000000000000000000000000000000000010\";\n\nconst bridgeAbiDeposit = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_l1Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"address\",\n        name: \"_l2Token\",\n        type: \"address\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_amount\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint32\",\n        name: \"_minGasLimit\",\n        type: \"uint32\",\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"depositERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20DepositInitiated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20WithdrawalFinalized\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHWithdrawalFinalized\",\n    type: \"event\",\n  },\n];\n\nconst bridgeAbiWithdrawal = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"WithdrawalInitiated\",\n    type: \"event\",\n  },\n];\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbiDeposit);\nconst bridgeContract = new ethers.Contract(\n  BASE_BRIDGE_DEPOSIT_CONTRACT,\n  bridgeAbiDeposit,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHDeposits() {\n  console.log(\"getETHDeposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ethdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ETHDepositInitiated(sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber, symbol: \"ETH\" });\n\n        ev.getTransaction().then((tx) => {\n          const { value, hash } = tx;\n          // console.log(\"tx\", tx);\n          const amount = ethers.utils.formatUnits(value, 18);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\nfunction getERC20Deposits() {\n  console.log(\"getERC20Deposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ercdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ERC20DepositInitiated(_, _, sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber });\n\n        ev.getTransaction().then((tx) => {\n          // console.log(\"tx\", tx);\n          const { hash, data } = tx;\n          const decodedData = bridgeIface.parseTransaction({ data });\n          const [l1Token, l2Token, value] = decodedData.args;\n          const token = tokens.find((t) => t.address === l1Token);\n          const amount = ethers.utils.formatUnits(value, token?.decimals || 6);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n            symbol: token?.symbol || \"???\",\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\ngetETHDeposits();\ngetERC20Deposits();\n\nfunction renderDeposit(deposit) {\n  //   console.log(\"deposit\", deposit);\n  const { timestamp, amount, transactionHash, symbol } = deposit;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli.\" : \"\"\n  }etherscan.io/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n  return (\n    <tr>\n      <td>{date.toUTCString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n    </tr>\n  );\n}\n\nconst { ethdeposits, ercdeposits } = state;\nconst deposits = [...ethdeposits, ...ercdeposits].sort(\n  (a, b) => b.timestamp - a.timestamp\n);\n\nconst bridgeContractWithdrawal = new ethers.Contract(\n  BASE_BRIDGE_WITHDRAW_CONTRACT,\n  bridgeAbiWithdrawal,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHWithdrawals() {\n  // console.log(\"getETHWithdrawals\");\n  const withdrawals = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      // console.log(\"done\");\n      State.update({\n        withdrawals,\n      });\n    }\n  }\n\n  bridgeContractWithdrawal\n    .queryFilter(\n      bridgeContractWithdrawal.filters.WithdrawalInitiated(\n        undefined,\n        undefined,\n        sender\n      )\n    )\n    .then((events) => {\n      console.log(\"WithdrawalInitiated\", events);\n      totalOperations = events.length * 1; // Three async operations for each event\n\n      events\n        .sort((a, b) => b.blockNumber - a.blockNumber)\n        .forEach((event) => {\n          const { args, logIndex, blockNumber, transactionHash } = event;\n          const [l1token, l2token, from, to, amount, extraData] = args;\n          // console.log(transactionHash, event);\n          const token = tokens.find((t) => t.address === l1token);\n\n          withdrawals.set(transactionHash, {\n            l1token,\n            l2token,\n            // from,\n            // to,\n            symbol: token?.symbol ?? \"????\",\n            amount: ethers.utils.formatUnits(amount, token?.decimals || 18),\n            extraData,\n            logIndex,\n            blockNumber,\n            transactionHash,\n          });\n\n          event.getBlock().then((block) => {\n            // console.log(transactionHash, \"block\", block);\n            const { timestamp } = block;\n            withdrawals.set(transactionHash, {\n              ...withdrawals.get(transactionHash),\n              timestamp,\n            });\n            completedOperations++;\n            checkAllOperationsComplete();\n          });\n        });\n    });\n}\n\ngetETHWithdrawals();\n\nfunction renderWithdrawal([_, withdrawal]) {\n  // console.log(\"withdraw\", withdrawal);\n  const { timestamp, amount, transactionHash, symbol } = withdrawal;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli-optimism.etherscan.io\" : \"optimistic.etherscan.io\"\n  }/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n  return (\n    <tr>\n      <td>{date.toUTCString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n      <td>status</td>\n      <td>\n        <button>action</button>\n      </td>\n    </tr>\n  );\n}\n\nreturn (\n  <Container>\n    <Tabs.Root className=\"TabsRoot\" defaultValue=\"deposits\">\n      <Tabs.List className=\"TabsList\" aria-label=\"Transactions List\">\n        <Tabs.Trigger className=\"TabsTrigger\" value=\"deposits\">\n          Deposits\n        </Tabs.Trigger>\n        <Tabs.Trigger className=\"TabsTrigger\" value=\"withdrawals\">\n          Withdrawals\n        </Tabs.Trigger>\n      </Tabs.List>\n      <Tabs.Content className=\"TabsContent\" value=\"deposits\">\n        {!isEthNetwork ? (\n          <h6>Switch to Ethereum network to see the deposits list.</h6>\n        ) : (\n          <>\n            <table>\n              <thead>\n                <tr>\n                  <th>Time</th>\n                  <th>Amount</th>\n                  <th>Token</th>\n                  <th>Transaction</th>\n                </tr>\n              </thead>\n              <tbody>{deposits.map(renderDeposit)}</tbody>\n            </table>\n          </>\n        )}\n      </Tabs.Content>\n      <Tabs.Content className=\"TabsContent\" value=\"withdrawals\">\n        {!isBaseNetwork ? (\n          <h6>Switch to BASE network to see the withdrawal list.</h6>\n        ) : (\n          <>\n            <table>\n              <thead>\n                <tr>\n                  <th>Time</th>\n                  <th>Amount</th>\n                  <th>Token</th>\n                  <th>Transaction</th>\n                  <th>Status</th>\n                  <th></th>\n                </tr>\n              </thead>\n              <tbody>{[...state.withdrawals].map(renderWithdrawal)}</tbody>\n            </table>\n          </>\n        )}\n      </Tabs.Content>\n    </Tabs.Root>\n  </Container>\n);\n"
    },
    "ciocan.near/widget/op-stack-bridge-ui": {
      "code": "const textColor = props.textColor ?? \"#35A39F\";\nconst bgColor = props.bgColor ?? \"#1B706D\";\n\nconst Layout = styled.div`\n  position: relative;\n  width: 314px;\n  min-height: 412px;\n  background-color: #151718;\n  border-radius: 14px;\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 24px;\n\n  .container {\n    position: relative;\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    padding: 0;\n  }\n\n  .container-button {\n    position: relative;\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 10px;\n    line-height: 12px;\n    cursor: pointer;\n  }\n\n  .separator {\n    border: 1px solid rgba(255, 255, 255, 0.1);\n    margin-left: 8px;\n    margin-right: 8px;\n  }\n\n  .info {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 400;\n    font-size: 10px;\n    line-height: 12px;\n    list-style: none;\n    padding: 0 8px 0 8px;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n    color: #fff;\n\n    li {\n      display: flex;\n      justify-content: space-between;\n    }\n\n    .value {\n      color: #35A39F;\n      font-weight: 600;\n    }\n  }\n`;\n\nconst ContainerNetwork = styled.div`\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  margin-left: 16px;\n\n  .label {\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 8px;\n    line-height: 10px;\n    color: #fff;\n  }\n`;\n\nconst NetworkSelectorButton = styled.button`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 4px 8px 4px 4px;\n  gap: 4px;\n\n  height: 24px;\n  outline: none;\n  border: none;\n  position: relative;\n\n  background: #2d2f30;\n  border-radius: 12px;\n\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 10px;\n  line-height: 12px;\n\n  color: #FFFFFF;\n`;\n\nconst NetworkList = styled.div`\n  position: absolute;\n  top: 0;\n  left: 0;\n  border-radius: 12px;\n  width: 145px;\n  background: #2d2f30;\n  z-index: 10;\n  box-shadow: inset 0px 0px 0px 1px #999;\n\n  ul {\n    display: flex;\n    flex-direction: column;\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    border-radius: 12px;\n  }\n\n  li {\n    display: flex;\n    justify-content: flex-start;\n    align-items: center;\n    padding: 4px 8px 4px 4px;\n    gap: 4px;\n    flex: 1;\n    width: 100%;\n    color: #fff;\n\n    &:hover {\n      color: #ccc;\n    }\n  }\n`;\n\nconst CloseButton = styled.button`\n  color: white;\n  background: none;\n  float: right;\n  margin-left: 12px;\n`;\n\nconst caretSvg = (\n  <svg width=\"6\" height=\"4\" viewBox=\"0 0 6 4\" fill=\"none\">\n    <path\n      d=\"M4.99998 1L2.99999 3L1 1\"\n      stroke=\"white\"\n      stroke-width=\"1.21738\"\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n    />\n  </svg>\n);\n\nconst TokenContainer = styled.div`\n  display: flex;\n  align-items: center;\n  padding: 16px;\n  gap: 12px;\n  position: relative;\n\n  width: 100%;\n\n  background: #2d2f30;\n  border-radius: 12px;\n\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 10px;\n  line-height: 12px;\n\n  color: #FFFFFF;\n\n  input::-webkit-outer-spin-button,\n  input::-webkit-inner-spin-button {\n    -webkit-appearance: none;\n    margin: 0;\n  }\n\n  input[type=\"number\"] {\n    -moz-appearance: textfield;\n  }\n\n  h3 {\n    font-family: 'Inter';\n    font-style: normal;\n    font-weight: 600;\n    font-size: 8px;\n    line-height: 10px;\n    color: rgba(255, 255, 255, 0.6);\n  }\n\n  .token-container {\n    display: flex;\n    flex-direction: column;\n    gap: 0;\n  }\n\n  .input-container {\n    display: flex;\n    flex-direction: column;\n    gap: 4px;\n    justify-content: flex-end;\n    flex: 1;\n\n    .usd-value {\n      text-align: right;\n    }\n  }\n`;\n\nconst TokenSelector = styled.button`\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 16px;\n  line-height: 19px;\n  color: #FFFFFF;\n  background: none;\n  border: none;\n  padding: 0;\n  margin: 0;\n`;\n\nconst Input = styled.input`\n  background: none;\n  color: #fff;\n  text-align: right;\n  border: none;\n  outline: none;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 16px;\n  line-height: 19px;\n  width: 100%;\n`;\n\nconst ToNetworkContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  padding: 4px 8px 4px 4px;\n  gap: 4px;\n\n  height: 24px;\n  outline: none;\n  border: none;\n  position: relative;\n\n  background: #2d2f30;\n  border-radius: 12px;\n\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 10px;\n  line-height: 12px;\n\n  color: #FFFFFF;\n`;\n\nconst ActionButton = styled.button`\n  background: ${bgColor};\n  border-radius: 4px;\n  border: 0;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 14px;\n  line-height: 17px;\n  color: #fff;\n  padding: 12px;\n`;\n\nconst Alert = styled.div`\n  position: absolute;\n  color: red;\n  background: #fff;\n  z-index: 20;\n  padding: 8px;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 12px;\n`;\n\nconst Dialog = styled.div`\n  position: absolute;\n  right: 32px;\n  left: 32px;\n  top: 25%;\n  background: #2d2f30;\n  z-index: 10;\n  box-shadow: inset 0px 0px 0px 1px #999;\n  border-radius: 12px;\n  padding: 16px; 8px;\n  font-family: 'Inter';\n  font-style: normal;\n  font-weight: 600;\n  font-size: 14px;\n\n  ul {\n    list-style: none;\n    padding: 0;\n    margin: 0;\n    display: flex;\n    flex-direction: column;\n  }\n\n  li {\n    display: flex;\n    justify-content: space-between;\n    cursor: pointer;\n    color: #fff;\n\n    &:hover {\n      color: #ccc;\n    }\n  }\n\n  .token {\n    display: flex;\n    gap: 8px;\n    align-items: center;\n  }\n\n`;\n\nconst { walletChains } = VM.require(\"ciocan.near/widget/op-stack-module\");\n\nconst tokens = props.tokens ?? [\n  {\n    chainId: 5,\n    address: \"0x0000000000000000000000000000000000000000\",\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    chainId: 5,\n    address: \"0xc1dC2d65A2243c22344E725677A3E3BEBD26E604\",\n    symbol: \"MNT\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/Mantle/logo.svg\",\n  },\n  {\n    chainId: 5001,\n    address: \"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\",\n    // address: \"0x0000000000000000000000000000000000000000\",\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/ETH/logo.svg\",\n  },\n  {\n    chainId: 5001,\n    address: \"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\",\n    symbol: \"MNT\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/Mantle/logo.svg\",\n  },\n];\nconst l2Network = props.l2Network ?? \"mantle\";\nconst l2TestnetId = props.l2TestnetId ?? 5001;\nconst l2MainnetId = props.l2MainnetId ?? 5000;\nconst l2Networks = props.l2Networks ?? {\n  [l2MainnetId]: \"Mantle\",\n  [l2TestnetId]: \"Mantle Testnet\",\n};\nconst l2IconUrl =\n  props.l2IconUrl ?? \"https://token-list.mantle.xyz/data/Mantle/logo.svg\";\n\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst networks = {\n  1: \"Ethereum Mainnet\",\n  5: \"Ethereum Goerli\",\n  ...l2Networks,\n};\n\nState.init({\n  selectedToken: \"ETH\",\n  isNetworkSelectOpen: false,\n  isTokenDialogOpen: false,\n  amount: 0,\n  balances: {},\n  prices: {},\n  isToastOpen: false,\n});\n\nconst {\n  isNetworkSelectOpen,\n  chainId,\n  selectedToken,\n  isTokenDialogOpen,\n  amount,\n  balances,\n  prices,\n} = state;\n\nconst selectedNetwork = chainId === 1 || chainId === 5 ? \"ethereum\" : l2Network;\n\nconst isTestnet = chainId === 5 || chainId === l2TestnetId;\nconst isMainnet = chainId === 1 || chainId === l2MainnetId;\n\nconst switchNetwork = (chainId) => {\n  Ethers.provider()\n    .send(\"wallet_switchEthereumChain\", [\n      { chainId: `0x${chainId.toString(16)}` },\n    ])\n    .catch((err) => {\n      if (err.code === 4902) {\n        Ethers.provider()\n          .send(\"wallet_addEthereumChain\", [walletChains[chainId]])\n          .then(() => {\n            Ethers.provider().send(\"wallet_switchEthereumChain\", [\n              { chainId: `0x${chainId.toString(16)}` },\n            ]);\n          });\n      }\n    });\n};\n\nconst coinsMap = {\n  ethereum: \"ETH\",\n  \"usd-coin\": \"USDC\",\n  mantle: \"MNT\",\n};\nconst coins = Object.keys(coinsMap);\nconst pricesUrl = `https://api.coingecko.com/api/v3/simple/price?ids=${coins.join(\n  \",\"\n)}&vs_currencies=usd`;\n\nif (!prices[selectedToken]) {\n  asyncFetch(pricesUrl).then((res) => {\n    if (!res.ok) return;\n    const prices = {};\n    coins.forEach((coin) => (prices[coinsMap[coin]] = res.body[coin].usd));\n    State.update({ prices });\n  });\n}\n\nconst updateBalance = (token) => {\n  const { address, decimals, symbol } = token;\n  // console.log(\"updateBalance\", address, symbol, chainId);\n  // if (state.balances[symbol]) {\n  //   return;\n  // }\n\n  if (symbol === \"ETH\" && [1, 5].includes(chainId)) {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balanceBig) => {\n        const adjustedBalance = ethers.utils.formatEther(balanceBig);\n        State.update({\n          balances: {\n            ...state.balances,\n            [symbol]: Number(adjustedBalance).toFixed(4),\n          },\n        });\n      });\n  } else {\n    const erc20Abi = [\"function balanceOf(address) view returns (uint256)\"];\n    const tokenContract = new ethers.Contract(\n      address,\n      erc20Abi,\n      Ethers.provider()\n    );\n    tokenContract.balanceOf(sender).then((balanceBig) => {\n      const adjustedBalance = ethers.utils.formatUnits(balanceBig, decimals);\n      State.update({\n        balances: {\n          ...state.balances,\n          [symbol]: Number(Number(adjustedBalance).toFixed(4)),\n        },\n      });\n    });\n  }\n};\n\ntokens.filter((t) => t.chainId === chainId).map(updateBalance);\n\nconst changeNetwork = (network) => {\n  console.log(network);\n  if (isTestnet) {\n    if (network === l2Network) {\n      switchNetwork(l2TestnetId);\n    } else {\n      switchNetwork(5);\n    }\n  } else {\n    if (network === l2Network) {\n      switchNetwork(l2MainnetId);\n    } else {\n      switchNetwork(1);\n    }\n  }\n  State.update({ isNetworkSelectOpen: false, selectedNetwork: network });\n  //   tokens.filter((t) => t.chainId === chainId).map(updateBalance);\n};\n\nconst openNetworkList = () => {\n  if (props.disableNetworkChange) return;\n  State.update({ isNetworkSelectOpen: true, isTokenDialogOpen: false });\n};\n\nconst isCorrectNetwork = Object.keys(networks)\n  .map((n) => Number(n))\n  .includes(chainId);\n\nconst getFromNetworkLabel = () => {\n  switch (selectedNetwork) {\n    case \"ethereum\":\n      return isMainnet ? networks[1] : networks[5];\n    case l2Network:\n      return isMainnet ? networks[l2MainnetId] : networks[l2TestnetId];\n    default:\n      return \"unknown\";\n  }\n};\n\nconst getToNetworkLabel = () => {\n  switch (selectedNetwork) {\n    case \"ethereum\":\n      return isMainnet ? networks[l2MainnetId] : networks[l2TestnetId];\n    case l2Network:\n      return isMainnet ? networks[1] : networks[5];\n    default:\n      return \"unknown\";\n  }\n};\n\nconst getToken = (tokenSymbol) =>\n  tokens\n    .filter(\n      (t) =>\n        t.chainId ===\n        (isMainnet\n          ? selectedNetwork === \"ethereum\"\n            ? 1\n            : l2MainnetId\n          : selectedNetwork === \"ethereum\"\n          ? 5\n          : l2TestnetId)\n    )\n    .find((t) => t.symbol === tokenSymbol);\n\nconst updateToken = (tokenSymbol) => {\n  State.update({ selectedToken: tokenSymbol, isTokenDialogOpen: false });\n\n  const { onUpdateToken } = props;\n  if (onUpdateToken) {\n    const token = getToken(tokenSymbol);\n    onUpdateToken({ amount, token, network: selectedNetwork });\n  }\n};\n\nconst openTokenDialog = () => {\n  State.update({ isTokenDialogOpen: true });\n};\n\nconst changeAmount = (e) => {\n  const amount = Number(e.target.value);\n  State.update({ amount });\n\n  const { onChangeAmount } = props;\n  if (onChangeAmount) {\n    const token = getToken(selectedToken);\n    onChangeAmount({ amount, token, network: selectedNetwork });\n  }\n};\n\nconst onOpenChange = (v) => {\n  State.update({\n    isToastOpen: false,\n  });\n};\n\nconst handleConfirm = () => {\n  console.log(state);\n  const isValidAmount = amount > 0 && amount < balances[selectedToken];\n\n  if (!isValidAmount) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid amount\",\n      description: \"Amount should be less than token balance\",\n    });\n    return;\n  }\n\n  const isL2Network = chainId === l2MainnetId || chainId === l2TestnetId;\n  if (selectedNetwork === \"ethereum\" && isL2Network) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid network\",\n      description: `Please switch to ${l2Network} network`,\n    });\n    return;\n  }\n\n  if (selectedNetwork === l2Network && !isL2Network) {\n    State.update({\n      isToastOpen: true,\n      variant: \"error\",\n      title: \"Invalid network\",\n      description: \"Please switch to ethereum network\",\n    });\n    return;\n  }\n\n  const { onConfirm } = props;\n  if (onConfirm) {\n    const token = getToken(selectedToken);\n    onConfirm({ amount, token, network: selectedNetwork });\n  }\n};\n\nconst networkList = isMainnet ? [1, l2MainnetId] : [5, l2TestnetId];\nconst token = tokens.find((t) => t.symbol === selectedToken);\n\nconst { isToastOpen, variant, title, description } = state;\n\nconsole.log(state);\n\nreturn (\n  <Layout>\n    <div class=\"container\">\n      {!isCorrectNetwork && (\n        <Alert>Please switch to Ethereum or {l2Network} network</Alert>\n      )}\n      <ContainerNetwork>\n        <span class=\"label\">FROM</span>\n        <div class=\"container-button\">\n          <NetworkSelectorButton onClick={openNetworkList}>\n            {selectedNetwork === \"ethereum\" ? (\n              <img\n                style={{ width: \"16px\" }}\n                src=\"https://assets.coingecko.com/coins/images/279/small/ethereum.png\"\n              />\n            ) : (\n              <img style={{ width: \"16px\" }} src={l2IconUrl} />\n            )}\n            <span>{getFromNetworkLabel()}</span>\n            {caretSvg}\n          </NetworkSelectorButton>\n          {isNetworkSelectOpen && (\n            <NetworkList>\n              <ul>\n                <li onClick={(e) => changeNetwork(\"ethereum\")}>\n                  <img\n                    style={{ width: \"16px\" }}\n                    src=\"https://assets.coingecko.com/coins/images/279/small/ethereum.png\"\n                  />\n                  <span>{networks[networkList[0]]}</span>\n                </li>\n                <li onClick={(e) => changeNetwork(l2Network)}>\n                  <img style={{ width: \"16px\" }} src={l2IconUrl} />\n                  <span>{networks[networkList[1]]}</span>\n                </li>\n              </ul>\n            </NetworkList>\n          )}\n        </div>\n      </ContainerNetwork>\n      <TokenContainer>\n        <img style={{ width: \"32px\" }} src={token?.logoURI} />\n        <div class=\"token-container\">\n          <h3>SEND -&gt;</h3>\n          <TokenSelector disabled={!isCorrectNetwork} onClick={openTokenDialog}>\n            <span>{selectedToken}</span>\n            {caretSvg}\n          </TokenSelector>\n        </div>\n        <div class=\"input-container\">\n          <Input placeholder=\"0\" type=\"number\" onChange={changeAmount} />\n          <span class=\"usd-value\">${prices[selectedToken] * amount}</span>\n        </div>\n      </TokenContainer>\n    </div>\n    <div class=\"container\">\n      <ContainerNetwork>\n        <span class=\"label\">TO</span>\n        <ToNetworkContainer>\n          {selectedNetwork === l2Network ? (\n            <img\n              style={{ width: \"16px\" }}\n              src=\"https://assets.coingecko.com/coins/images/279/small/ethereum.png\"\n            />\n          ) : (\n            <img style={{ width: \"16px\" }} src={l2IconUrl} />\n          )}\n          <span>{getToNetworkLabel()}</span>\n        </ToNetworkContainer>\n      </ContainerNetwork>\n      <TokenContainer>\n        <img style={{ width: \"32px\" }} src={token?.logoURI} />\n        <div class=\"token-container\">\n          <h3>-&gt; RECEIVE</h3>\n          <TokenSelector>\n            <span>{selectedToken}</span>\n          </TokenSelector>\n        </div>\n        <div class=\"input-container\">\n          <Input type=\"number\" readOnly value={amount} />\n          <span class=\"usd-value\">${prices[selectedToken] * amount}</span>\n        </div>\n      </TokenContainer>\n    </div>\n    <div class=\"separator\" />\n    <ul class=\"info\">\n      <li>\n        <span>Rate</span>\n        <span class=\"value\">\n          1 {selectedToken} = ${prices[selectedToken]}\n        </span>\n      </li>\n    </ul>\n    <ActionButton onClick={handleConfirm} disabled={!isCorrectNetwork}>\n      Confirm\n    </ActionButton>\n    {isTokenDialogOpen && (\n      <Dialog>\n        <CloseButton onClick={() => State.update({ isTokenDialogOpen: false })}>\n          x\n        </CloseButton>\n        <ul>\n          {tokens\n            .filter((t) => t.chainId === chainId)\n            .map((token) => {\n              const { symbol, logoURI } = token;\n              return (\n                <li key={symbol} onClick={() => updateToken(symbol)}>\n                  <div class=\"token\">\n                    <img style={{ width: \"16px\" }} src={logoURI} />\n                    <span>{symbol}</span>\n                  </div>\n                  <span>{state.balances[symbol] ?? \"-\"}</span>\n                </li>\n              );\n            })}\n        </ul>\n      </Dialog>\n    )}\n    <Widget\n      src=\"ciocan.near/widget/toast\"\n      props={{ open: isToastOpen, variant, title, description, onOpenChange }}\n    />\n  </Layout>\n);\n"
    },
    "ciocan.near/widget/op-stack-mantle-bridge": {
      "code": "const Container = styled.div`\n  display: flex;\n  gap: 8px;\n\n  .side {\n    margin-top: 20px;\n  }\n\n  .w3button button {\n    background-color: #854ce6;\n    color: white;\n    border: none;\n    border-radius: 30px;\n    padding: 12px 15px;\n  }\n`;\n\nconst Layout = styled.div`\n  display: flex;\n  flex-direction: column;\n  .title {\n    margin-left: 20px;\n    color: #666;\n  }\n  .link {\n    margin-top: 1rem;\n    a {\n        color: black;\n    }\n  }\n`;\n\nconst { tokens, ethAbi, erc20Abi } = VM.require(\n  \"ciocan.near/widget/op-stack-module\"\n);\n\nconst l2Network = \"mantle\";\nconst l2TestnetId = 5001;\nconst l2MainnetId = 5000;\nconst l2Networks = {\n  [l2MainnetId]: \"Mantle\",\n  [l2TestnetId]: \"Mantle Testnet\",\n};\nconst l2IconUrl = \"https://token-list.mantle.xyz/data/Mantle/logo.svg\";\n\nState.init({\n  gasLimit: ethers.BigNumber.from(\"300000\"),\n  isToastOpen: false,\n});\n\nconst { chainId, variant, title, description, isToastOpen, gasLimit } = state;\nconst isMainnet = chainId === 1 || chainId === l2MainnetId;\n\nconst onOpenChange = (v) => {\n  State.update({\n    isToastOpen: false,\n  });\n};\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nfunction showToast({ variant, title, description }) {\n  State.update({\n    isToastOpen: true,\n    variant: variant ?? \"error\",\n    title: title ?? \"Transaction rejected\",\n    description: description ?? \"The transaction was rejected\",\n  });\n}\n\nfunction handleDepositETH(props) {\n  console.log(\"handleDepositETH\", props);\n  const { amount, token } = props;\n  const amountBig = ethers.utils.parseUnits(`${amount}`, 18);\n\n  const bridgeEthIface = new ethers.utils.Interface(ethAbi);\n  const encodedData = bridgeEthIface.encodeFunctionData(\n    \"depositETH(uint32, bytes)\",\n    [200000, 0]\n  );\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: token.extensions.optimismBridgeAddress,\n      data: encodedData,\n      value: amountBig,\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"depositETH ok:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"depositETH error:\", e);\n      if (e.reason) {\n        showToast({ description: e.reason });\n      } else {\n        showToast({\n          variant: \"success\",\n          title: \"SUCCESS\",\n          description: \"ETH deposit ok\",\n        });\n      }\n    });\n}\n\nfunction handleDepositERC20(props) {\n  console.log(\"handleDepositERC20\", props);\n  const MNT_MIN_GAS = `200000`;\n  const ERC20_APPROVE_GAS = `81942`;\n  const ERC20_TRANSFER_GAS = `192460`;\n  const { amount, token } = props;\n\n  const l2ChainId = isMainnet ? l2MainnetId : l2TestnetId;\n  const tokenL2 = tokens\n    .filter((t) => t.symbol === token.symbol)\n    .find((t) => t.chainId === l2ChainId);\n\n  const bridgeErc20Iface = new ethers.utils.Interface(erc20Abi);\n  const erc20Contract = new ethers.Contract(\n    token.address,\n    bridgeErc20Iface,\n    provider.getSigner()\n  );\n  const bridgeContract = new ethers.Contract(\n    token.extensions.optimismBridgeAddress,\n    bridgeErc20Iface,\n    provider.getSigner()\n  );\n\n  const amountBig = ethers.utils.parseUnits(`${amount}`, token.decimals);\n\n  erc20Contract\n    .approve(token.extensions.optimismBridgeAddress, amountBig, {\n      gasLimit: ERC20_APPROVE_GAS,\n    })\n    .then((approveData) => {\n      console.log(\"approve\", approveData);\n\n      bridgeContract\n        .depositERC20(\n          token.address,\n          tokenL2.address,\n          amountBig,\n          MNT_MIN_GAS,\n          [],\n          {\n            gasLimit: ERC20_TRANSFER_GAS,\n          }\n        )\n        .then((tx) => {\n          console.log(\"depositERC20 ok\", tx);\n          showToast({\n            variant: \"success\",\n            title: \"SUCCESS\",\n            description: \"ERC20 deposit ok\",\n          });\n        })\n        .catch((e) => {\n          console.log(\"depositERC20 error:\", e);\n          showToast({ description: e.reason });\n        });\n    })\n    .catch((e) => {\n      console.log(\"approve error:\", e);\n      showToast({ description: e.reason });\n    });\n}\n\nconst onConfirm = (props) => {\n  console.log(\"onConfirm\", props);\n  const { network, token } = props;\n  if (network !== \"ethereum\") {\n    showToast({\n      title: \"Please switch to Ethereum\",\n      description: \"withdrawals are not yet supported\",\n    });\n    return;\n  }\n  if (token.symbol === \"ETH\") {\n    handleDepositETH(props);\n  } else {\n    handleDepositERC20(props);\n  }\n};\n\nconst onChangeAmount = (props) => {\n  console.log(\"onChangeAmount\", props);\n};\n\nconst onUpdateToken = (props) => {\n  console.log(\"onUpdateToken\", props);\n};\n\nif (!sender) {\n  return (\n    <Container>\n      <div className=\"w3button\">\n        <Web3Connect connectLabel=\"Connect to a wallet\" />\n      </div>\n    </Container>\n  );\n}\n\nconst depositsUrl = `https://bridge${\n  isMainnet ? \"\" : \".testnet\"\n}.mantle.xyz/account/deposit`;\n\nreturn (\n  <Layout>\n    <div class=\"title\">\n      <h5>Mantle Bridge</h5>\n    </div>\n    <Container>\n      <Widget\n        src=\"ciocan.near/widget/op-stack-bridge-ui\"\n        props={{\n          onConfirm,\n          onUpdateToken,\n          onChangeAmount,\n          tokens,\n          l2Network,\n          l2TestnetId,\n          l2MainnetId,\n          l2Networks,\n          l2IconUrl,\n          disableNetworkChange: true,\n        }}\n      />\n      <Widget\n        src=\"ciocan.near/widget/toast\"\n        props={{ open: isToastOpen, variant, title, description, onOpenChange }}\n      />\n    </Container>\n    <div class=\"link\">\n      To check the deposit status{\" \"}\n      <a href={depositsUrl} target=\"_blank\">\n        click here\n      </a>\n    </div>\n  </Layout>\n);\n"
    },
    "ciocan.near/widget/op-stack-module": {
      "code": "const tokens = [\n  // eth testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n    extensions: {\n      optimismBridgeAddress: \"0xc92470D7Ffa21473611ab6c6e2FcFB8637c8f330\",\n    },\n  },\n  {\n    chainId: 5,\n    address: \"0xc1dC2d65A2243c22344E725677A3E3BEBD26E604\",\n    symbol: \"MNT\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/Mantle/logo.svg\",\n    extensions: {\n      optimismBridgeAddress: \"0xc92470D7Ffa21473611ab6c6e2FcFB8637c8f330\",\n    },\n  },\n  {\n    address: \"0x07865c6E87B9F70255377e024ace6630C1Eaa37F\",\n    chainId: 5,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n    extensions: {\n      optimismBridgeAddress: \"0xc92470D7Ffa21473611ab6c6e2FcFB8637c8f330\",\n    },\n  },\n  // eth mainnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n    extensions: {\n      optimismBridgeAddress: \"0x95fC37A27a2f68e3A647CDc081F0A89bb47c3012\",\n    },\n  },\n  {\n    chainId: 1,\n    address: \"0x3c3a81e81dc49a522a592e7622a7e711c06bf354\",\n    name: \"Mantle\",\n    symbol: \"MNT\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/Mantle/logo.svg\",\n    extensions: {\n      optimismBridgeAddress: \"0x95fC37A27a2f68e3A647CDc081F0A89bb47c3012\",\n    },\n  },\n  {\n    address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n    chainId: 1,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n    extensions: {\n      optimismBridgeAddress: \"0x95fC37A27a2f68e3A647CDc081F0A89bb47c3012\",\n    },\n  },\n  // mantle testnet assets\n  {\n    chainId: 5001,\n    address: \"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\",\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/ETH/logo.svg\",\n    extensions: {\n      optimismBridgeAddress: \"0x4200000000000000000000000000000000000010\",\n    },\n  },\n  {\n    chainId: 5001,\n    address: \"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\",\n    symbol: \"MNT\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/Mantle/logo.svg\",\n    extensions: {\n      optimismBridgeAddress: \"0x4200000000000000000000000000000000000010\",\n    },\n  },\n  {\n    chainId: 5001,\n    address: \"0x2ED3c15eC59CE827c4aBBabfF76d37562558437D\",\n    name: \"USD Coin\",\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI: \"https://token-list.mantle.xyz/data/USDC/logo.png\",\n    extensions: {\n      optimismBridgeAddress: \"0x4200000000000000000000000000000000000010\",\n    },\n  },\n  // mantle assets\n  {\n    chainId: 5000,\n    address: \"0xdEAddEaDdeadDEadDEADDEAddEADDEAddead1111\",\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/ETH/logo.svg\",\n    extensions: {\n      optimismBridgeAddress: \"0x4200000000000000000000000000000000000010\",\n    },\n  },\n  {\n    chainId: 5000,\n    address: \"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\",\n    name: \"Mantle\",\n    symbol: \"MNT\",\n    decimals: 18,\n    logoURI: \"https://token-list.mantle.xyz/data/Mantle/logo.svg\",\n    extensions: {\n      optimismBridgeAddress: \"0x4200000000000000000000000000000000000010\",\n    },\n  },\n  {\n    chainId: 5000,\n    address: \"0x09Bc4E0D864854c6aFB6eB9A9cdF58aC190D0dF9\",\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI: \"https://token-list.mantle.xyz/data/USDC/logo.png\",\n    extensions: {\n      optimismBridgeAddress: \"0x4200000000000000000000000000000000000010\",\n    },\n  },\n];\n\nconst walletChains = {\n  5001: {\n    chainId: `0x1389`,\n    chainName: \"Mantle Testnet\",\n    nativeCurrency: {\n      name: \"Ethereum\",\n      symbol: \"ETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://rpc.testnet.mantle.xyz/\"],\n  },\n  5000: {\n    chainId: `0x1388`,\n    chainName: \"Mantle Mainnet\",\n    nativeCurrency: {\n      name: \"Ethereum\",\n      symbol: \"ETH\",\n      decimals: 18,\n    },\n    rpcUrls: [\"https://rpc.mantle.xyz\"],\n  },\n};\n\nconst ethAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"_l2Gas\", type: \"uint32\" },\n      { internalType: \"bytes\", name: \"_data\", type: \"bytes\" },\n    ],\n    name: \"depositETH\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ETHDepositInitiated\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l1Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"l2Token\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"from\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"to\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n      {\n        indexed: false,\n        internalType: \"bytes\",\n        name: \"extraData\",\n        type: \"bytes\",\n      },\n    ],\n    name: \"ERC20DepositInitiated\",\n    type: \"event\",\n  },\n];\n\nconst erc20Abi = [\n  {\n    constant: false,\n    inputs: [\n      {\n        type: \"address\",\n      },\n      {\n        type: \"uint256\",\n      },\n    ],\n    name: \"approve\",\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    constant: false,\n    inputs: [\n      {\n        type: \"address\",\n      },\n      {\n        type: \"address\",\n      },\n      {\n        type: \"uint256\",\n      },\n      {\n        type: \"uint32\",\n      },\n      {\n        type: \"bytes\",\n      },\n    ],\n    name: \"depositERC20\",\n    payable: false,\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        type: \"address\",\n      },\n      {\n        type: \"address\",\n      },\n    ],\n    outputs: [\n      {\n        type: \"uint256\",\n      },\n    ],\n    name: \"allowance\",\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    constant: true,\n    inputs: [\n      {\n        type: \"address\",\n      },\n    ],\n    outputs: [\n      {\n        type: \"uint256\",\n      },\n    ],\n    name: \"balanceOf\",\n    payable: false,\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n\nreturn { tokens, walletChains, ethAbi, erc20Abi };\n"
    },
    "ciocan.near/widget/op-stack-list-deposits": {
      "code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst { tokens, ethAbi, erc20Abi } = VM.require(\n  \"ciocan.near/widget/op-stack-module\"\n);\n\nState.init({\n  ethdeposits: [],\n  ercdeposits: [],\n});\n\nconst { chainId } = state;\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst {\n  opTestnetChainId,\n  opMainnetChainId,\n  opTestnetBridgeAddress,\n  opMainnetBridgeAddress,\n} = props;\n\nconst isTestnet = chainId === 5 || chainId === opTestnetChainId;\n\nif (![1, 5].includes(chainId)) {\n  return <h6>Switch to Ethereum network to see the deposits list.</h6>;\n}\n\nconst OP_BRIDGE_DEPOSIT_CONTRACT = isTestnet\n  ? opTestnetBridgeAddress ?? \"0xc92470D7Ffa21473611ab6c6e2FcFB8637c8f330\"\n  : opMainnetBridgeAddress ?? \"0x95fC37A27a2f68e3A647CDc081F0A89bb47c3012\";\n\nconst bridgeAbi = [...ethAbi, ...erc20Abi];\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\nconst bridgeContract = new ethers.Contract(\n  OP_BRIDGE_DEPOSIT_CONTRACT,\n  bridgeAbi,\n  Ethers.provider().getSigner()\n);\n\nfunction getETHDeposits() {\n  // console.log(\"getETHDeposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ethdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ETHDepositInitiated(sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber, symbol: \"ETH\" });\n\n        ev.getTransaction().then((tx) => {\n          const { value, hash } = tx;\n          // console.log(\"tx\", tx);\n          const amount = ethers.utils.formatUnits(value, 18);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\nfunction getERC20Deposits() {\n  console.log(\"getERC20Deposits\");\n  const deposits = new Map();\n  let completedOperations = 0;\n  let totalOperations = 0;\n\n  function checkAllOperationsComplete() {\n    if (completedOperations === totalOperations) {\n      console.log(\"done\");\n      State.update({\n        ercdeposits: [...deposits].map(([transactionHash, data]) => ({\n          ...data,\n          transactionHash,\n        })),\n      });\n    }\n  }\n\n  bridgeContract\n    .queryFilter(bridgeContract.filters.ERC20DepositInitiated(_, _, sender))\n    .then((events) => {\n      // console.log(events);\n      totalOperations = events.length * 3; // Three async operations for each event\n\n      events.forEach((ev) => {\n        const { blockNumber, transactionHash } = ev;\n        deposits.set(transactionHash, { blockNumber });\n\n        ev.getTransaction().then((tx) => {\n          // console.log(\"tx\", tx);\n          const { hash, data } = tx;\n          const decodedData = bridgeIface.parseTransaction({ data });\n          const [l1Token, l2Token, value] = decodedData.args;\n          const token = tokens.find((t) => t.address === l1Token);\n          const amount = ethers.utils.formatUnits(value, token?.decimals || 6);\n          deposits.set(hash, {\n            ...deposits.get(hash),\n            amount,\n            symbol: token?.symbol || \"???\",\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getTransactionReceipt().then((tx) => {\n          // console.log(\"txr\", tx);\n          const { status, type, transactionHash } = tx;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            status,\n            type,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n        ev.getBlock().then((block) => {\n          // console.log(transactionHash, \"block\", block);\n          const { timestamp } = block;\n          deposits.set(transactionHash, {\n            ...deposits.get(transactionHash),\n            timestamp,\n          });\n          completedOperations++;\n          checkAllOperationsComplete();\n        });\n      });\n    });\n}\n\ngetETHDeposits();\ngetERC20Deposits();\n\nfunction renderDeposit(deposit) {\n  //   console.log(\"deposit\", deposit);\n  const { timestamp, amount, transactionHash, symbol } = deposit;\n  const date = new Date(timestamp * 1000);\n  const href = `https://${\n    isTestnet ? \"goerli.\" : \"\"\n  }etherscan.io/tx/${transactionHash}`;\n  const hash = `${transactionHash.substr(0, 6)}...${transactionHash.substr(\n    -4\n  )}`;\n\n  return (\n    <tr>\n      <td>{date.toLocaleString()}</td>\n      <td>{amount}</td>\n      <td>{symbol}</td>\n      <td>\n        <a href={href} target=\"_blank\">\n          {hash}\n        </a>\n      </td>\n    </tr>\n  );\n}\n\nconst { ethdeposits, ercdeposits } = state;\nconst deposits = [...ethdeposits, ...ercdeposits].sort(\n  (a, b) => b.timestamp - a.timestamp\n);\n\nreturn (\n  <table>\n    <thead>\n      <tr>\n        <th>Date</th>\n        <th>Amount</th>\n        <th>Token</th>\n        <th>Transaction</th>\n      </tr>\n    </thead>\n    <tbody>{deposits.map(renderDeposit)}</tbody>\n  </table>\n);\n"
    },
    "ciocan.near/widget/bos-showcase": {
      "code": "return <div>bos showcase here</div>;\n"
    },
    "src/widget/bos-showcase": {
      "code": "const Main = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  margin-bottom: 2rem;\n`;\n\nconst HeroImage = styled.img`\n  display: block;\n  width: 100%;\n  height: 400px;\n  object-fit: cover;\n  object-position: center;\n  background-color: #ccc;\n  padding: 0 0.5rem;\n  border-radius: 0.75rem;\n  max-width: 1216px;\n  margin: 0 auto;\n  margin-bottom: 1rem;\n`;\n\nconst caretRight = (\n  <svg\n    width=\"10\"\n    height=\"16\"\n    viewBox=\"0 0 10 16\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n  >\n    <path\n      d=\"M2.45898 16L0.857422 14.3175L5.65431 9.22887L6.79165 7.99503L5.65431 6.77113L0.857422 1.69072L2.45898 0L10.0003 8L2.45898 16Z\"\n      fill=\"#C7C7C7\"\n    />\n  </svg>\n);\n\nconst Container = styled.div`\n  display: grid;\n  grid-template-columns: repeat(3, 400px);\n  gap: 0.5rem;\n  justify-content: center;\n\n  @media (max-width: 1200px) {\n    grid-template-columns: repeat(2, 1fr);\n  }\n\n  @media (max-width: 800px) {\n    grid-template-columns: 1fr;\n  }\n`;\n\nconst SectionTitle = styled.h1`\n  color: #11181c;\n  font-size: 1.5rem;\n  font-weight: bold;\n  margin-top: 1.5rem;\n  padding-left: 0.75rem;\n  border-left: 5px solid ${({ color }) => color};\n`;\n\nconst GatewayCard = styled.a`\n  display: flex;\n  flex-direction: column;\n  text-decoration: none !important;\n`;\n\nconst GatewayImg = styled.img`\n  width: 100%;\n  height: 200px;\n  object-fit: cover;\n  object-position: center;\n  background-color: #ccc;\n  border-top-left-radius: 0.66rem;\n  border-top-right-radius: 0.66rem;\n`;\n\nconst GatewayContainer = styled.div`\n  display: flex;\n  align-items: center;\n  border: 1px solid #e0e0e0;\n  padding: 1rem;\n  border-bottom-left-radius: 0.66rem;\n  border-bottom-right-radius: 0.66rem;\n  justify-content: space-between;\n`;\n\nconst Card = styled.a`\n  display: flex;\n  align-items: center;\n  border: 1px solid #e0e0e0;\n  padding: 1rem;\n  border-radius: 0.66rem;\n  justify-content: space-between;\n  text-decoration: none !important;\n`;\n\nconst Circle = styled.div`\n  width: 48px;\n  height: 48px;\n  background-color: grey;\n  border-radius: 50%;\n  margin-right: 0.75rem;\n`;\n\nconst Title = styled.h4`\n  margin: 0;\n  margin-right: auto;\n  font-size: 1rem;\n  font-weight: semibold;\n  color: #000;\n`;\n\nconst Type = styled.span`\n  background-color: ${({ bg }) => bg};\n  color: ${({ color }) => color};\n  padding: 5px 10px;\n  border-radius: 99px;\n  font-size: 0.875rem;\n  font-weight: semibold;\n  margin-right: 0.75rem;\n`;\n\nconst Dapp = ({ title, type, url }) => (\n  <Card href={url} target=\"_blank\">\n    <Circle />\n    <Title>{title}</Title>\n    <Type color=\"#0a6846\" bg=\"#b1ffd0\">\n      {type}\n    </Type>\n    {caretRight}\n  </Card>\n);\n\nconst Gateway = ({ title, type, url }) => (\n  <GatewayCard href={url} target=\"_blank\">\n    <GatewayImg src={url} />\n    <GatewayContainer>\n      <Circle />\n      <Title>{title}</Title>\n      <Type color=\"#4A0A68\" bg=\"#F4D3FF\">\n        {type}\n      </Type>\n      {caretRight}\n    </GatewayContainer>\n  </GatewayCard>\n);\n\nconst Resource = ({ title, type, url }) => (\n  <Card href={url} target=\"_blank\">\n    <Circle />\n    <Title>{title}</Title>\n    <Type color=\"#232323\" bg=\"#EEEEEE\">\n      {type}\n    </Type>\n    {caretRight}\n  </Card>\n);\n\nconst dapps = [\n  { title: \"Uniswap v1\", type: \"DEX\", url: \"https://near.org/\" },\n  { title: \"Uniswap v2\", type: \"DEX\", url: \"https://near.org/\" },\n  { title: \"Aave V3\", type: \"Lending\", url: \"https://near.org/\" },\n  { title: \"Lido\", type: \"Staking\", url: \"https://near.org/\" },\n  { title: \"Gamma\", type: \"Liquidity\", url: \"https://near.org/\" },\n  { title: \"Pendle\", type: \"Yield Aggregator\", url: \"https://near.org/\" },\n];\n\nconst gateways = [\n  { title: \"DapDap\", type: \"Web3 Games\", url: \"https://near.org/\" },\n  { title: \"Polygon zkEVM\", type: \"zkEVM\", url: \"https://near.org/\" },\n  { title: \"Mantle\", type: \"zkEVM\", url: \"https://near.org/\" },\n];\n\nconst resources = [\n  { title: \"What is BOS?\", type: \"Docs\", url: \"https://near.org/\" },\n  { title: \"BOS Viewer\", type: \"Github Repo\", url: \"https://near.org/\" },\n  {\n    title: \"BOS Lightweight Gateway\",\n    type: \"Github Repo\",\n    url: \"https://near.org/\",\n  },\n  {\n    title: \"BOS Decentralized Frontends\",\n    type: \"Telegram Chat\",\n    url: \"https://near.org/\",\n  },\n];\n\nreturn (\n  <Main>\n    <HeroImage src=\"\" />\n    <Container>\n      <SectionTitle color=\"#00EC97\">Dapps</SectionTitle>\n    </Container>\n    <Container>\n      {dapps.map(({ title, type }, index) => (\n        <Dapp key={index} title={title} type={type} />\n      ))}\n    </Container>\n    <Container>\n      <SectionTitle color=\"#C751FF\">Gateways</SectionTitle>\n    </Container>\n    <Container>\n      {gateways.map(({ title, type }, index) => (\n        <Gateway key={index} title={title} type={type} />\n      ))}\n    </Container>\n    <Container>\n      <SectionTitle color=\"#767676\">Resources</SectionTitle>\n    </Container>\n    <Container>\n      {resources.map(({ title, type }, index) => (\n        <Resource key={index} title={title} type={type} />\n      ))}\n    </Container>\n  </Main>\n);\n"
    }
  }
}